package Dancer2::Cookbook;
# ABSTRACT: Example-driven quick-start to the Dancer2 web framework

=pod

=encoding utf8

=head1 DESCRIPTION

A quick-start guide with examples to get you up and running with the Dancer2 web
framework.


=head1 BEGINNER'S DANCE

=head2 Your first Dancer2 web app

Dancer2 has been designed to be easy to work with - it's trivial to write a
simple web app, but still has the power to work with larger projects.  To start
with, let's make an incredibly simple "Hello World" example:

    #!/usr/bin/perl

    use Dancer2;

    get '/hello/:name' => sub {
        return "Why, hello there " . params->{name};
    };

    dance;

Yes - the above is a fully-functioning web app; running that script will launch
a webserver listening on the default port (3000); now you can make a request

    $ curl http://localhost:3000/hello/Bob
    Why, hello there Bob

(or the name of the machine you ran it on, if it's not your local system),
and it will say hello.  The C<:name> part is a named parameter within the
route specification, whose value is made available through C<params>
- more on that later.

Note that you don't need to use the C<strict> and C<warnings> pragma, they are
already loaded by Dancer2.

If you I<really> do not want the C<warnings> pragma (for example, due to an
undesired warning about use of undef values), add a C<no warnings> pragma to
the appropriate block in your module or psgi file.

=head2 Starting a Dancer2 project

The first simple example is fine for trivial projects, but for anything more
complex, you'll want a more maintainable solution - enter the C<dancer2> helper
script, which will build the framework of your application with a single
command:

    $ dancer2 -a mywebapp
    + mywebapp
    + mywebapp/bin
    + mywebapp/bin/app.pl
    + mywebapp/config.yml
    + mywebapp/environments
    + mywebapp/environments/development.yml
    + mywebapp/environments/production.yml
    + mywebapp/views
    + mywebapp/views/index.tt
    + mywebapp/views/layouts
    + mywebapp/views/layouts/main.tt
    + mywebapp/MANIFEST.SKIP
    + mywebapp/lib
      mywebapp/lib/
    + mywebapp/lib/mywebapp.pm
    + mywebapp/public
    + mywebapp/public/css
    + mywebapp/public/css/style.css
    + mywebapp/public/css/error.css
    + mywebapp/public/images
    + mywebapp/public/500.html
    + mywebapp/public/404.html
    + mywebapp/public/dispatch.fcgi
    + mywebapp/public/dispatch.cgi
    + mywebapp/public/javascripts
    + mywebapp/public/javascripts/jquery.js
    + mywebapp/t
    + mywebapp/t/002_index_route.t
    + mywebapp/t/001_base.t
    + mywebapp/Makefile.PL


As you can see, it creates a directory named after the name of the app, along
with a configuration file, a views directory (where your templates and layouts
will live), an environments directory (where environment-specific settings
live), a module containing the actual guts of your application, a script to
start it - or to run your web app via Plack/PSGI - more on that later.



=head1 DANCE ROUTINES: ROUTES

=head2 Declaring routes

To control what happens when a web request is received by your webapp, you'll
need to declare C<routes>.  A route declaration indicates which HTTP method(s)
it is valid for, the path it matches (e.g. /foo/bar), and a coderef to execute,
which returns the response.

    get '/hello/:name' => sub {
        return "Hi there " . params->{name};
    };

The above route specifies that, for GET requests to '/hello/...', the code block
provided should be executed.

=head2 Handling multiple HTTP request methods

Routes can use C<any> to match all, or a specified list of HTTP methods.

The following will match any HTTP request to the path /myaction:

    any '/myaction' => sub {
        # code
    }

The following will match GET or POST requests to /myaction:

    any ['get', 'post'] => '/myaction' => sub {
        # code
    };

For convenience, any route which matches GET requests will also match HEAD
requests.



=head2 Retrieving request parameters

The L<params|Dancer2/params> keyword returns a hashref of request parameters;
these will be parameters supplied on the query string, within the path itself
(with named placeholders), and, for HTTTP POST requests, the content of the
POST body.



=head2 Named parameters in route path declarations

As seen above, you can use C<:somename> in a route's path to capture part of the
path; this will become available by calling L<params|Dancer2/params>.

So, for a web app where you want to display information on a company, you might
use something like:

    get '/company/view/:companyid' => sub {
        my $company_id = params->{companyid};
        # Look up the company and return appropriate page
    };



=head2 Wildcard path matching and splat

You can also declare wildcards in a path, and retrieve the values they matched
with the L<splat|Dancer2/splat> keyword:

    get '/*/*' => sub {
        my ($action, $id) = splat;
        if (my $action eq 'view') {
            return display_item($id);
        } elsif ($action eq 'delete') {
            return delete_item($id);
        } else {
            status 'not_found';
            return "What?";
        }
    };



=head2 Before filters - processed before a request

A L<before|Dancer2/before> filter declares code which should be handled before
a request is passed to the appropriate route.

    hook before => sub {
        forward '/foo/oversee', { note => 'Hi there' };
    };

    get '/foo/*' => sub {
        my ($match) = splat; # 'oversee';
        params->{note};      # 'Hi there'
    };

The above declares a before filter which uses C<forward> to do an internal
redirect to C</foo/oversee> with an additional parameter C<note>.

See also the L<hook|Dancer2/hook> hook keyword.

=head2 Default route

In case you want to avoid a I<404 error>, or handle multiple routes in the same
way and you don't feel like configuring all of them, you can set up a default
route handler.

The default route handler will handle any request that doesn't get served by
any other route.

All you need to do is set up the following route as the B<last> route:

    any qr{.*} => sub {
        status 'not_found';
        template 'special_404', { path => request->path };
    };

Then you can set up the template as such:

    You tried to reach [% path %], but it is unavailable at the moment.

    Please try again or contact us at our email at <...>.


=head2 Using the auto_page feature for automatic route creation

For simple "static" pages, you can simply enable the C<auto_page> config
setting; this means that you need not declare a route handler for those pages;
if a request is for C</foo/bar>, Dancer2 will check for a matching view (e.g.
C</foo/bar.tt> and render it with the default layout etc if found.  For full
details, see the documentation for the
L<auto_page setting|Dancer2::Config/"auto_page">.



=head2 Why should I use the Ajax plugin

As an Ajax query is just a HTTP query, it's similar to a GET or POST
route. You may ask yourself why you may want to use the C<ajax>
keyword (from the L<Dancer2::Plugin::Ajax> plugin) instead of a simple
C<get>.

Let's say you have a path like '/user/:user' in your application. You
may want to be able to serve this page, with a layout and HTML
content. But you may also want to be able to call this same url from a
javascript query using Ajax.

So, instead of having the following code:

    get '/user/:user' => sub {
         if (request->is_ajax) {
             # create xml, set headers to text/xml, blablabla
              header('Content-Type' => 'text/xml');
              header('Cache-Control' =>  'no-store, no-cache, must-revalidate');
              to_xml({...})
         }else{
             template users, {....}
         }
    };

you can have

    get '/user/:user' => sub {
        template users, {...}
    }

and

    ajax '/user/:user' => sub {
         to_xml({...}, RootName => undef);
    }


Because it's an ajax query, you know you need to return a xml content,
so the content type of the response is set for you.



=head2 Using the prefix feature to split your application

For better maintainability, you may want to separate some of your application
components to different packages. Let's say we have a simple web app with an
admin section, and want to maintain this in a different package:

    package myapp;
    use Dancer2;
    use myapp::admin;

    prefix undef;

    get '/' => sub {...};

    1;

    package myapp::admin;
    use Dancer2;

    prefix '/admin';

    get '/' => sub {...};

    1;

The following routes will be generated for us:

    - get /
    - get /admin/
    - head /
    - head /admin/



=head1 MUSCLE MEMORY: STORING DATA

=head2 Handling sessions

It's common to want to use sessions to give your web applications state; for
instance, allowing a user to log in, creating a session, and checking that
session on subsequent requests.

To make use of sessions, you must first enable the session engine - pick the
session engine you want to use, then declare it in your config file like this:

    session: Simple

The L<Dancer2::Session::Simple> backend implements very simple in-memory session
storage.  This will be fast and useful for testing, but sessions do not persist
between restarts of your app.

You can also use the L<Dancer2::Session::YAML> backend included with Dancer2,
which stores session data on disc in YAML files (since YAML is a nice
human-readable format, it makes inspecting the contents of sessions a breeze):

    session: YAML

Or, to enable session support from within your code,

    set session => 'YAML';

(Controlling settings is best done from your config file, though).  'YAML' in
the example is the session backend to use; this is shorthand for
L<Dancer2::Session::YAML>.  There are other session backends you may wish to use,
for instance L<Dancer2::Session::Memcache>, but the YAML backend is a simple and
easy to use example which stores session data in a YAML file in sessions).

You can then use the L<session|Dancer2/session> keyword to manipulate the
session:

=head3 Storing data in the session

Storing data in the session is as easy as:

    session varname => 'value';



=head3 Retrieving data from the session

Retrieving data from the session is as easy as:

    session('varname')

Or, alternatively,

    session->read("varname")



=head3 Controlling where sessions are stored

For disc-based session back ends like L<Dancer2::Session::YAML>,
L<Dancer2::Session::Storable> etc, session files are written to the session dir
specified by the C<session_dir> setting, which defaults to C<./sessions> if
not specifically set.

If you need to control where session files are created, you can do so quickly
and easily within your config file, for example:

    session: YAML
    engines:
      session:
        YAML:
          session_dir: /tmp/dancer-sessions

If the directory you specify does not exist, Dancer2 will attempt to create it
for you.

=head3 Destroying a session

When you're done with your session, you can destroy it:

    app->destroy_session

=head2 Sessions and logging in

A common requirement is to check the user is logged in, and, if not, require
them to log in before continuing.

This can easily be handled with a before filter to check their session:

    use Dancer2;
    set session => "Simple";

    hook before => sub {
        if (!session('user') && request->dispatch_path !~ m{^/login}) {
            forward '/login', { requested_path => request->dispatch_path };
        }
    };

    get '/' => sub { return "Home Page"; };

    get '/secret' => sub { return "Top Secret Stuff here"; };

    get '/login' => sub {
        # Display a login page; the original URL they requested is available as
        # param('requested_path'), so could be put in a hidden field in the form
        template 'login', { path => param('requested_path') };
    };

    post '/login' => sub {
        # Validate the username and password they supplied
        if (param('user') eq 'bob' && param('pass') eq 'letmein') {
            session user => param('user');
            redirect param('path') || '/';
        } else {
            redirect '/login?failed=1';
        }
    };

    dance();

Here is what the corresponding C<login.tt> file should look like. You should place
it in a directory called views:

    <html>
      <head>
        <title>Session and logging in</title>
      </head>
      <body>
        <form action='/login' method='POST'>
            User Name : <input type='text' name='user'/>
            Password: <input type='password' name='pass' />

            <!-- Put the original path requested into a hidden
                       field so it's sent back in the POST and can be
                       used to redirect to the right page after login -->
            <input type='hidden' name='path' value='[% path %]'/>

            <input type='submit' value='Login' />
        </form>
      </body>
    </html>

Of course, you'll probably want to validate your users against a database table,
or maybe via IMAP/LDAP/SSH/POP3/local system accounts via PAM etc.
L<Authen::Simple> is probably a good starting point here!

A simple working example of handling authentication against a database table
yourself (using L<Dancer2::Plugin::Database> which provides the C<database>
keyword, and L<Crypt::SaltedHash> to handle salted hashed passwords (well, you
wouldn't store your users passwords in the clear, would you?)) follows:

    post '/login' => sub {
        my $user = database->quick_select('users',
            { username => params->{user} }
        );
        if (!$user) {
            warning "Failed login for unrecognised user " . params->{user};
            redirect '/login?failed=1';
        } else {
            if (Crypt::SaltedHash->validate($user->{password}, params->{pass}))
            {
                debug "Password correct";
                # Logged in successfully
                session user => $user;
                redirect params->{path} || '/';
            } else {
                debug("Login failed - password incorrect for " . params->{user});
                redirect '/login?failed=1';
            }
        }
    };



=head3 Retrieve complete hash stored in session

Get complete hash stored in session:

    my $hash = session;



=head1 APPEARANCE: TEMPLATES AND LAYOUTS

Returning plain content is all well and good for examples or trivial apps, but
soon you'll want to use templates to maintain separation between your code and
your content.  Dancer2 makes this easy.

Your route handlers can use the L<template|Dancer2::Manual/template> keyword to render
templates.

=head2 Views

It's possible to render the action's content with a template, this is called a
view. The `appdir/views' directory is the place where views are located.

You can change this location by changing the setting 'views'.

By default, the internal template engine L<Dancer2::Template::Simple> is used,
but you may want to upgrade to L<Template Toolkit|http://www.template-toolkit.org/>. If you do so, you have to
enable this engine in your settings as explained in
L<Dancer2::Template::TemplateToolkit>  and you'll also have to
import the L<Template> module in your application code.

All views must have a '.tt' extension. This may change in the future.

In order to render a view, just call the L<template|Dancer2::Manual/template> keyword at
the end of the action by giving the view name and the HASHREF of tokens to
interpolate in the view (note that for convenience, the request, session, params
and vars are automatically accessible in the view, named C<request>, C<session>,
C<params> and C<vars>) - for example:

    hook before => sub { var time => scalar(localtime) };

    get '/hello/:name' => sub {
        my $name = params->{name};
        template 'hello.tt', { name => $name };
    };

The template C<hello.tt> could contain, for example:

    <p>Hi there, [% name %]!</p>
    <p>You're using [% request.user_agent %]</p>
    [% IF session.username %]
        <p>You're logged in as [% session.username %]</p>
    [% END %]
    It's currently [% vars.time %]

For a full list of the tokens automatically added to your template
(like C<session>, C<request> and C<vars>, refer to
L<Dancer2::Core::Role::Template>).

=head2 Layouts

A layout is a special view, located in the 'layouts' directory (inside the views
directory) which must have a token named C<content>. That token marks the place
where to render the action view. This lets you define a global layout for your
actions, and have each individual view contain only the specific content.  This
is a good thing to avoid lots of needless duplication of HTML :)

Here is an example of a layout: C<views/layouts/main.tt> :

    <html>
        <head>...</head>
        <body>
        <div id="header">
        ...
        </div>

        <div id="content">
        [% content %]
        </div>

        </body>
    </html>

You can tell your app which layout to use with C<layout: name> in the config
file, or within your code:

    set layout => 'main';

You can control which layout to use (or whether to use a layout at all) for a
specific request without altering the layout setting by passing an options
hashref as the third param to the template keyword:

    template 'index.tt', {}, { layout => undef };

If your application is not mounted under root (B</>), you can use a
before_template instead of hardcoding the path to your application for your
css, images and javascript:

    hook before_template_render => sub {
        my $tokens = shift;
        $tokens->{uri_base} = request->base->path;
    };

Then in your layout, modify your css inclusion as follows:

    <link rel="stylesheet" href="[% uri_base %]/css/style.css" />

From now on, you can mount your application wherever you want, without
any further modification of the css inclusion

=head2 Templates and unicode

If you use L<Plack> and have some unicode problem with your Dancer2 application,
don't forget to check if you have set your template engine to use unicode, and
set the default charset to UTF-8. So, if you are using template toolkit, your
config file will look like this:

    charset: UTF-8
    engines:
      template:
        template_toolkit:
          ENCODING: utf8


=head2 TT's WRAPPER directive in Dancer2

Dancer2 already provides a WRAPPER-like ability, which we call a "layout". The
reason we do not use TT's WRAPPER (which also makes us incompatible with it) is
because not all template systems support it. Actually, most don't.

However, you might want to use it, and be able to define META variables and
regular L<Template::Toolkit> variables.

These few steps will get you there:

=over 4

=item * Disable the layout in Dancer2

You can do this by simply commenting (or removing) the C<layout> configuration
in the config file.

=item * Use Template Toolkit template engine

Change the configuration of the template to Template Toolkit:

    # in config.yml
    template: "template_toolkit"

=item * Tell the Template Toolkit engine who's your wrapper

    # in config.yml
    # ...
    engines:
        template:
            template_toolkit:
                WRAPPER: layouts/main.tt

=back

Done! Everything will work fine out of the box, including variables and META
variables.



=head1 SETTING THE STAGE: CONFIGURATION AND LOGGING

=head2 Configuration and environments

Configuring a Dancer2 application can be done in many ways. The easiest one (and
maybe the dirtiest) is to put all your settings statements at the top of
your script, before calling the dance() method.

Other ways are possible, you can define all your settings in the file
C<appdir/config.yml>. For this, you must have installed the YAML module, and of
course, write the config file in YAML.

That's better than the first option, but it's still not perfect as you can't
switch easily from an environment to another without rewriting the config
file.

An even solution is to have one config.yml file with default global settings,
like the following:

    # appdir/config.yml
    logger: 'file'
    layout: 'main'

And then write as many environment files as you like in C<appdir/environments>.
That way, the appropriate environment config file will be loaded according to
the running environment (if none is specified, it will be 'development').

Note that you can change the running environment using the C<--environment>
command line switch.

Typically, you'll want to set the following values in a development config file:

    # appdir/environments/development.yml
    log: 'debug'
    startup_info: 1
    show_errors:  1

And in a production one:

    # appdir/environments/production.yml
    log: 'warning'
    startup_info: 0
    show_errors:  0



=head2 Accessing configuration information

=head3 From inside your application

A Dancer2 application can use the 'config' keyword to easily access the settings
within its config file, for instance:

    get '/appname' => sub {
        return "This is " . config->{appname};
    };

This makes keeping your application's settings all in one place simple and easy
- you shouldn't need to worry about implementing all that yourself :)


=head3 From a separate script

You may well want to access your webapp's configuration from outside your
webapp. You could, of course, use the YAML module of your choice and load your
webapps's config.yml, but chances are that this is not convenient.

Use Dancer2 instead. Without any ado, magic or too big jumps, you can use the
values from config.yml and some additional default values:

    # bin/script1.pl
    use Dancer2;
    print "template:".config->{template}."\n"; #simple
    print "log:".config->{log}."\n"; #undef

Note that C<< config->{log} >> should result undef error on a default scaffold since
you did not load the environment and in the default scaffold log is defined in
the environment and not in config.yml. Hence undef.

If you want to load an environment you need to tell Dancer2 where to look for it.
One way to do so, is to tell Dancer2 where the webapp lives. From there Dancer2
deduces where the config.yml file is (typically C<$webapp/config.yml>).

    # bin/script2.pl
    use FindBin;
    use Cwd qw/realpath/;
    use Dancer2;

    #tell the Dancer2 where the app lives
    my $appdir=realpath( "$FindBin::Bin/..");

    Dancer2::Config::setting('appdir',$appdir);
    Dancer2::Config::load();

    #getter
    print "environment:".config->{environment}."\n"; #development
    print "log:".config->{log}."\n"; #value from development environment

By default Dancer2 loads development environment (typically
C<$webapp/environment/development.yml>). In contrast to the example before,  you
do have a value from the development environment (C<environment/development.yml>)
now. Also note that in the above example L<Cwd> and L<FindBin> are used. They are
likely to be already loaded by Dancer2 anyways, so it's not a big overhead. You
could just as well hand over a simple path for the app if you like that better,
e.g.:

    Dancer2::Config::setting('appdir','/path/to/app/dir');

If you want to load an environment other than the default, try this:

    # bin/script2.pl
    use Dancer2;

    #tell the Dancer2 where the app lives
    Dancer2::Config::setting('appdir','/path/to/app/dir');

    #which environment to load
    config->{environment}='production';

    Dancer2::Config::load();

    #getter
    print "log:".config->{log}."\n"; #has value from production environment

By the way, you not only get values, you can also set values straightforward
like we do above with C<< config->{environment}='production' >>. Of course, this value
does not get written in any file; it only lives in memory and your webapp
doesn't have access to it, but you can use it inside your script.



=head2 Logging

=head3 Configuring logging

It's possible to log messages generated by the application and by Dancer2 itself.

To start logging, select the logging engine you wish to use with the C<logger>
setting; Dancer2 includes built-in log engines named C<file> and C<console>,
which log to a logfile and to the console respectively.

To enable logging to a file, add the following to your config file:

    logger: 'file'

Then you can choose which kind of messages you want to actually log:

    log: 'core'      # will log debug, warnings, errors,
                     # and messages from Dancer2 itself
    log: 'debug'     # will log debug, info, warning and errors
    log: 'info'      # will log info, warning and errors
    log: 'warning'   # will log warning and errors
    log: 'error'     # will log only errors

If you're using the C<file> logging engine, a directory C<appdir/logs> will be
created and will host one logfile per environment. The log message contains the
time it was written, the PID of the current process, the message and the caller
information (file and line).

=head3 Logging your own messages

Just call  L<debug|Dancer2/debug>, L<info|Dancer2/info>,
L<warning|Dancer2/warning> or L<error|Dancer2/error> with your message:

    debug "This is a debug message from my app.";



=head1 RESTING

=head2 Writing a REST application

With Dancer2, it's easy to write REST applications. Dancer2 provides helpers to
serialize and deserialize for the following data formats:

=over 4

=item JSON

=item YAML

=item XML

=item Data::Dumper

=back

To activate this feature, you only have to set the C<serializer> setting to the
format you require, for instance in your config file:

   serializer: JSON

Or right in your code:

   set serializer => 'JSON';

From now, all hash ref or array ref returned by a route will be serialized to
the format you chose, and all data received from B<POST> or B<PUT> requests
will be automatically deserialized.

    get '/hello/:name' => sub {
        # this structure will be returned to the client as
        # {"name":"$name"}
        return {name => params->{name}};
    };

It's possible to let the client choose which serializer he want to use. For
this, use the B<mutable> serializer, and an appropriate serializer will be
chosen from the B<Content-Type> header.

It's also possible to return a custom error, using the
L<send_error|Dancer2/send_error> keyword..
When you don't use a serializer, the C<send_error> function will take a string
as first parameter (the message), and an optional HTTP code. When using a
serializer, the message can be a string, an arrayref or a hashref:

    get '/hello/:name' => sub {
        if (...) {
           send_error("you can't do that");
           # or
           send_error({reason => 'access denied', message => "no"});
        }
    };

The content of the error will be serialized using the appropriate serializer.


=head1 DANCER ON THE STAGE: DEPLOYMENT

=head2 Running stand-alone

At the simplest, your Dancer2 app can run standalone, operating as its own
webserver using L<HTTP::Server::PSGI>.

Simply fire up your app:

    $ perl bin/app.pl
    >> Listening on 0.0.0.0:3000
    == Entering the dance floor ...

Point your browser at it, and away you go!

This option can be useful for small personal web apps or internal apps, but if
you want to make your app available to the world, it probably won't suit you.

=head2 Auto Reloading with Plack and Shotgun

To edit your files without the need to restart the webserver on each file change,
simply start your Dancer2 app using L<plackup> and L<Plack::Loader::Shotgun>:

    $ plackup -L Shotgun bin/app.pl
    HTTP::Server::PSGI: Accepting connections at http://0:5000/

Point your browser at it. Files can now be changed in your favorite editor and
the browser needs to be refreshed to see the saved changes.

Please note that this is not recommended for production for performance reasons.
This is the Dancer2 replacement solution of the old Dancer experimental
C<auto_reload> option.

On Windows, Shotgun loader is known to cause huge memory leaks in a
fork-emulation layer. If you are aware of this and still want to run the loader,
please use the following command:

    > set PLACK_SHOTGUN_MEMORY_LEAK=1 && plackup -L Shotgun bin\app.pl
    HTTP::Server::PSGI: Accepting connections at http://0:5000/

=head2 CGI and Fast-CGI

In providing ultimate flexibility in terms of deployment, your Dancer2 app can
be run as a simple cgi-script out-of-the-box. No additional web-server
configuration needed.  Your web server should recognize .cgi files and be able
to serve Perl scripts.  The Perl module L<Plack::Runner> is required.

=head3 Running on Apache (CGI and FCGI)

Start by adding the following to your apache configuration (C<httpd.conf> or
C<sites-available/*site*>):

    <VirtualHost *:80>
        ServerName www.example.com
        DocumentRoot /srv/www.example.com/public
        ServerAdmin you@example.com

        <Directory "/srv/www.example.com/public">
           AllowOverride None
           Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
           Order allow,deny
           Allow from all
           AddHandler cgi-script .cgi
        </Directory>

        RewriteEngine On
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ /dispatch.cgi$1 [QSA,L]

        ErrorLog  /var/log/apache2/www.example.com-error.log
        CustomLog /var/log/apache2/www.example.com-access_log common
    </VirtualHost>

Note that when using fast-cgi your rewrite rule should be:

        RewriteRule ^(.*)$ /dispatch.fcgi$1 [QSA,L]

Here, the mod_rewrite magic for Pretty-URLs is directly put in Apache's configuration.
But if your web server supports .htaccess files, you can drop those lines in a .htaccess file.

To check if your server supports mod_rewrite type C<apache2 -l> to list modules.
To enable mod_rewrite (Debian), run C<a2enmod rewrite>. Place following code in
a file called .htaccess in your application's root folder:

    # BEGIN dancer application htaccess
    RewriteEngine On
    RewriteCond %{SCRIPT_FILENAME} !-d
    RewriteCond %{SCRIPT_FILENAME} !-f
    RewriteRule (.*) /dispatch.cgi$1 [L]
    # END dancer application htaccess

Now you can access your dancer application URLs as if you were using the
embedded web server.

    http://localhost/

This option is a no-brainer, easy to setup, low maintenance but serves requests
slower than all other options.

You can use the same technique to deploy with FastCGI, by just changing the line:

    AddHandler cgi-script .cgi

By:

    AddHandler fastcgi-script .fcgi

Of course remember to update your rewrite rules, if you have set any:

    RewriteRule (.*) /dispatch.fcgi$1 [L]


=head4 Running under an appdir

If you want to deploy multiple applications under the same VirtualHost, using
one application per directory for example, you can do the following.

This example uses the FastCGI dispatcher that comes with Dancer2, but you should
be able to adapt this to use any other way of deployment described in this
guide. The only purpose of this example is to show how to deploy multiple
applications under the same base directory/virtualhost.

    <VirtualHost *:80>
        ServerName localhost
        DocumentRoot "/path/to/rootdir"
        RewriteEngine On
        RewriteCond %{REQUEST_FILENAME} !-f

        <Directory "/path/to/rootdir">
            AllowOverride None
            Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
            Order allow,deny
            Allow from all
            AddHandler fastcgi-script .fcgi
        </Directory>

        RewriteRule /App1(.*)$ /App1/public/dispatch.fcgi$1 [QSA,L]
        RewriteRule /App2(.*)$ /App2/public/dispatch.fcgi$1 [QSA,L]
        ...
        RewriteRule /AppN(.*)$ /AppN/public/dispatch.fcgi$1 [QSA,L]
    </VirtualHost>

Of course, if your Apache configuration allows that, you can put the
RewriteRules in a .htaccess file directly within the application's directory,
which lets you add a new application without changing the Apache configuration.

=head3 Running on lighttpd (CGI)

To run as a CGI app on lighttpd, just create a soft link to the dispatch.cgi
script (created when you run dancer -a MyApp) inside your system's cgi-bin
folder. Make sure mod_cgi is enabled.

    ln -s /path/to/MyApp/public/dispatch.cgi /usr/lib/cgi-bin/mycoolapp.cgi

=head3 Running on lighttpd (FastCGI)

Make sure mod_fcgi is enabled. You also must have L<FCGI> installed.

This example configuration uses TCP/IP:

    $HTTP["url"] == "^/app" {
        fastcgi.server += (
            "/app" => (
                "" => (
                    "host" => "127.0.0.1",
                    "port" => "5000",
                    "check-local" => "disable",
                )
            )
        )
    }

Launch your application:

    plackup -s FCGI --port 5000 bin/app.pl

This example configuration uses a socket:

    $HTTP["url"] =~ "^/app" {
        fastcgi.server += (
            "/app" => (
                "" => (
                    "socket" => "/tmp/fcgi.sock",
                    "check-local" => "disable",
                )
            )
        )
    }

Launch your application:

    plackup -s FCGI --listen /tmp/fcgi.sock bin/app.pl


=head2 Plack middlewares

If you want to use Plack middlewares, you need to enable them using
L<Plack::Builder> as such:

    # in app.psgi or any other handler
    use Dancer2;
    use MyWebApp;
    use Plack::Builder;

    builder {
        enable 'Deflater';
        enable 'Session', store => 'File';
        enable 'Debug', panels => [ qw<DBITrace Memory Timer> ];
        dance;
    };


The nice thing about this setup is that it will work seamlessly through Plack
or through the internal web server.

    # load dev web server (without middlewares)
    perl -Ilib app.psgi

    # load plack web server (with middlewares)
    plackup -I lib app.psgi

You do not need to provide different files for either server.

=head3 Path-based middlewares

If you want to setup a middleware for a specific path, you can do that using
L<Plack::Builder> which uses L<Plack::App::URLMap>:

    # in your app.psgi or any other handler
    use Dancer2;
    use MyWebApp;
    use Plack::Builder;

    my $special_handler = sub { ... };

    builder {
        mount '/'        => dance;
        mount '/special' => $special_handler;
    };

=head3 Running on Perl webservers with plackup

A number of Perl web servers supporting PSGI are available on cpan:

=over 4

=item L<Starman>

C<Starman> is a high performance web server, with support for preforking, signals, ...

=item L<Twiggy>

C<Twiggy> is an C<AnyEvent> web server, it's light and fast.

=item L<Corona>

C<Corona> is a C<Coro> based web server.

=back

To start your application, just run plackup (see L<Plack> and specific servers
above for all available options):

   $ plackup bin/app.pl
   $ plackup -E deployment -s Starman --workers=10 -p 5001 -a bin/app.pl

As you can see, the scaffolded Perl script for your app can be used as a PSGI
startup file.

=head4 Enabling content compression

Content compression (gzip, deflate) can be easily enabled via a Plack
middleware (see L<Plack/Plack::Middleware>): L<Plack::Middleware::Deflater>.
It's a middleware to encode the response body in gzip or deflate, based on
Accept-Encoding HTTP request header.

Enable it as you would enable any Plack middleware. First you need to install
L<Plack::Middleware::Deflater>, then in the handler (usually F<app.psgi>) edit
it to use L<Plack::Builder>, as described above:

    use Dancer2;
    use MyWebApp;
    use Plack::Builder;

    builder {
        enable 'Deflater';
        dance;
    };

To test if content compression works, trace the HTTP request and response
before and after enabling this middleware. Among other things, you should
notice that the response is gzip or deflate encoded, and contains a header
C<Content-Encoding> set to C<gzip> or C<deflate>

=head3 Running multiple apps with Plack::Builder

You can use L<Plack::Builder> to mount multiple Dancer2 applications on
a L<PSGI> webserver like L<Starman>.

Start by creating a simple app.psgi file:

    use OurWiki;  # first app
    use OurForum; # second app
    use Plack::Builder;

    builder {
        mount '/wiki'  => OurWiki->dance;
        mount '/forum' => OurForum->dance;
    };

and now use L<Starman>

    plackup -a app.psgi -s Starman

Currently this still demands the same appdir for both (default circumstance)
but in a future version this will be easier to change while staying very
simple to mount.

=head3 Running from Apache with Plack

You can run your app from Apache using PSGI (Plack), with a config like the
following:

    <VirtualHost myapp.example.com>
        ServerName www.myapp.example.com
        ServerAlias myapp.example.com
        DocumentRoot /websites/myapp.example.com

        <Directory /home/myapp/myapp>
            AllowOverride None
            Order allow,deny
            Allow from all
        </Directory>

        <Location />
            SetHandler perl-script
            PerlResponseHandler Plack::Handler::Apache2
            PerlSetVar psgi_app /websites/myapp.example.com/app.pl
        </Location>

        ErrorLog  /websites/myapp.example.com/logs/error_log
        CustomLog /websites/myapp.example.com/logs/access_log common
    </VirtualHost>

To set the environment you want to use for your application (production or development), you can set it this way:

    <VirtualHost>
        ...
        SetEnv DANCER_ENVIRONMENT "production"
        ...
    </VirtualHost>

=head2 Creating a service

You can turn your app into proper service running in background using one of the following examples:

=head3 Using Ubic

L<Ubic> is an extensible perlish service manager. You can use it to start and stop any services, automatically start them on reboots or daemon failures, and implement custom status checks.

A basic PSGI service description (usually in /etc/ubic/service/application):

    use parent qw(Ubic::Service::Plack);

    # if your application is not installed in @INC path:
    sub start {
        my $self = shift;
        $ENV{PERL5LIB} = '/path/to/your/application/lib';
        $self->SUPER::start(@_);
    }

    __PACKAGE__->new(
        server => 'Starman',
        app => '/path/to/your/application/app.pl',
        port => 5000,
        user => 'www-data',
    );

Run C<ubic start application> to start the service.


=head3 Using daemontools

daemontools is a collection of tools for managing UNIX services. You can use it to easily start/restart/stop services.

A basic script to start an application: (in /service/application/run)

    #!/bin/sh

    # if your application is not installed in @INC path:
    export PERL5LIB='/path/to/your/application/lib'

    exec 2>&1 \
    /usr/local/bin/plackup -s Starman -a /path/to/your/application/app.pl -p 5000


=head2 Running stand-alone behind a proxy / load balancer

Another option would be to run your app stand-alone as described above, but then
use a proxy or load balancer to accept incoming requests (on the standard port
80, say) and feed them to your Dancer2 app.

This could be achieved using various software; examples would include:

=head3 Using Apache's mod_proxy

You could set up a VirtualHost for your web app, and proxy all requests through
to it:

    <VirtualHost mywebapp.example.com:80>
    ProxyPass / http://localhost:3000/
    ProxyPassReverse / http://localhost:3000/
    </VirtualHost>

Or, if you want your webapp to share an existing VirtualHost, you could have it
under a specified dir:

    ProxyPass /mywebapp/ http://localhost:3000/
    ProxyPassReverse /mywebapp/ http://localhost:3000/

It is important for you to note that the Apache2 modules C<mod_proxy> and C<mod_proxy_http>
must be enabled.

    a2enmod proxy
    a2enmod proxy_http

It is also important to set permissions for proxying for security purposes, below is an example.

    <Proxy *>
      Order allow,deny
      Allow from all
    </Proxy>

=head3 Using perlbal

C<perlbal> is a single-threaded event-based server written in Perl supporting HTTP load
balancing, web serving, and a mix of the two, available from
L<http://www.danga.com/perlbal/>

It processes hundreds of millions of requests a day just for LiveJournal, Vox
and TypePad and dozens of other "Web 2.0" applications.

It can also provide a management interface to let you see various information on
requests handled etc.

It could easily be used to handle requests for your Dancer2 apps, too.

It can be easily installed from CPAN:

    perl -MCPAN -e 'install Perlbal'

Once installed, you'll need to write a configuration file.  See the examples
provided with perlbal, but you'll probably want something like:

    CREATE POOL my_dancers
    POOL my_dancers ADD 10.0.0.10:3030
    POOL my_dancers ADD 10.0.0.11:3030
    POOL my_dancers ADD 10.0.0.12:3030
    POOL my_dancers ADD 10.0.0.13:3030

    CREATE SERVICE my_webapp
    SET listen          = 0.0.0.0:80
    SET role            = reverse_proxy
    SET pool            = my_dancers
    SET persist_client  = on
    SET persist_backend = on
    SET verify_backend  = on
    ENABLE my_webapp




=head3 Using balance

C<balance> is a simple load-balancer from Inlab Software, available from
L<http://www.inlab.de/balance.html>.

It could be used simply to hand requests to a standalone Dancer2 app. You could
even run several instances of your Dancer2 app, on the same machine or on several
machines, and use a machine running balance to distribute the requests between
them, for some serious heavy traffic handling!

To listen on port 80, and send requests to a Dancer2 app on port 3000:

    balance http localhost:3000

To listen on a specified IP only on port 80, and distribute requests between
multiple Dancer2 apps on multiple other machines:

    balance -b 10.0.0.1 80 10.0.0.2:3000 10.0.0.3:3000 10.0.0.4:3000


=head3 Using Lighttpd

You can use Lighttp's mod_proxy:

    $HTTP["url"] =~ "/application" {
        proxy.server = (
            "/" => (
                "application" => ( "host" => "127.0.0.1", "port" => 3000 )
            )
        )
    }

This configuration will proxy all request to the B</application> path
to the path B</> on localhost:3000.

=head3 Using Nginx

with Nginx:

    upstream backendurl {
        server unix:THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock;
    }

    server {
      listen       80;
      server_name YOUR_HOST_HERE;

      access_log /var/log/YOUR_ACCESS_LOG_HERE.log;
      error_log  /var/log/YOUR_ERROR_LOG_HERE.log info;

      root YOUR_ROOT_PROJECT/public;
      location / {
        try_files $uri @proxy;
        access_log off;
        expires max;
      }

      location @proxy {
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass       http://backendurl;
      }

    }

You will need plackup to start a worker listening on a socket :

    cd YOUR_PROJECT_PATH
    sudo -u www plackup -E production -s Starman --workers=2 -l THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock -a bin/app.pl

A good way to start this is to use C<daemontools> and place this line
with all environments variables in the "run" file.


=cut
