package Dancer2::Cookbook;
# ABSTRACT: Example-driven quick-start to the Dancer2 web framework

=pod

=encoding utf8

=head1 DESCRIPTION

A quick-start guide with examples to get you up and running with the Dancer2 web
framework.


=head1 BEGINNER'S DANCE

=head2 Your first Dancer2 web app

Dancer2 has been designed to be easy to work with - it's trivial to write a
simple web app, but still has the power to work with larger projects.  To start
with, let's make an incredibly simple "Hello World" example:

    #!/usr/bin/perl

    use Dancer2;

    get '/hello/:name' => sub {
        return "Why, hello there " . params->{name};
    };

    dance;

Yes - the above is a fully-functioning web app; running that script will launch
a webserver listening on the default port (3000); now you can make a request

    $ curl http://localhost:3000/hello/Bob
    Why, hello there Bob

(or the name of the machine you ran it on, if it's not your local system),
and it will say hello.  The C<:name> part is a named parameter within the
route specification, whose value is made available through C<params>
- more on that later.

Note that you don't need to use the C<strict> and C<warnings> pragma, they are
already loaded by Dancer2.

If you I<really> do not want the C<warnings> pragma (for example, due to an
undesired warning about use of undef values), add a C<no warnings> pragma to
the appropriate block in your module or psgi file.

=head2 Starting a Dancer2 project

The first simple example is fine for trivial projects, but for anything more
complex, you'll want a more maintainable solution - enter the C<dancer2> helper
script, which will build the framework of your application with a single
command:

    $ dancer2 -a mywebapp
    + mywebapp
    + mywebapp/bin
    + mywebapp/bin/app.pl
    + mywebapp/config.yml
    + mywebapp/environments
    + mywebapp/environments/development.yml
    + mywebapp/environments/production.yml
    + mywebapp/views
    + mywebapp/views/index.tt
    + mywebapp/views/layouts
    + mywebapp/views/layouts/main.tt
    + mywebapp/MANIFEST.SKIP
    + mywebapp/lib
      mywebapp/lib/
    + mywebapp/lib/mywebapp.pm
    + mywebapp/public
    + mywebapp/public/css
    + mywebapp/public/css/style.css
    + mywebapp/public/css/error.css
    + mywebapp/public/images
    + mywebapp/public/500.html
    + mywebapp/public/404.html
    + mywebapp/public/dispatch.fcgi
    + mywebapp/public/dispatch.cgi
    + mywebapp/public/javascripts
    + mywebapp/public/javascripts/jquery.js
    + mywebapp/t
    + mywebapp/t/002_index_route.t
    + mywebapp/t/001_base.t
    + mywebapp/Makefile.PL


As you can see, it creates a directory named after the name of the app, along
with a configuration file, a views directory (where your templates and layouts
will live), an environments directory (where environment-specific settings
live), a module containing the actual guts of your application, a script to
start it - or to run your web app via Plack/PSGI - more on that later.

=head2 Default Route

In case you want to avoid a I<404 error>, or handle multiple routes in the
same way and you don't feel like configuring all of them, you can set up a
default route handler.

The default route handler will handle any request that doesn't get served by
any other route.

All you need to do is set up the following route as the B<last> route:

    any qr{.*} => sub {
        status 'not_found';
        template 'special_404', { path => request->path };
    };

Then you can set up the template like so:

    You tried to reach [% path %], but it is unavailable at the moment.

    Please try again or contact us at <contact@example.com>.

=head2 Using the C<auto_page> feature for automatic route creation

For simple "static" pages you can simply enable the C<auto_page> config
setting; this means you don't need to declare a route handler for those
pages; if a request is for C</foo/bar>, Dancer2 will check for a matching
view (e.g. C</foo/bar.tt> and render it with the default layout etc. if
found. For full details, see the documentation for the L<auto_page
setting|Dancer2::Config/"auto_page">.

=head2 Simplifying AJAX queries with the Ajax plugin

As an AJAX query is just an HTTP query, it's similar to a GET or POST route.
You may ask yourself why you may want to use the C<ajax> keyword (from the
L<Dancer2::Plugin::Ajax> plugin) instead of a simple C<get>.

Let's say you have a path like C</user/:user> in your application. You may
want to be able to serve this page with a layout and HTML content. But you
may also want to be able to call this same url from a javascript query using
AJAX.

So, instead of having the following code:

    get '/user/:user' => sub {
         if (request->is_ajax) {
             # create xml, set headers to text/xml, blablabla
              header('Content-Type' => 'text/xml');
              header('Cache-Control' =>  'no-store, no-cache, must-revalidate');
              to_xml({...})
         }else{
             template users => {...}
         }
    };

you can have

    ajax '/user/:user' => sub {
         to_xml({...}, RootName => undef);
    }

and

    get '/user/:user' => sub {
        template users => {...}
    }

Because it's an AJAX query, you know you need to return XML content, so
the content type of the response is set for you.

=head3 Example: Feeding graph data through AJAX

Let us assume we are building an application that uses a plotting library 
to generate a graph and expects to get its data, which is in the form
of wordcount from an AJAX call.

For the graph, we need the url I</data> to return a JSON representation 
of the wordcount data. Dancer infact has a C<to_json()> function that takes 
care of the JSON encapsulation.

     get '/data' => sub {
         open my $fh, '<', $count_file;

         my %contestant;
         while (<$fh>) {
             chomp;
             my ( $date, $who, $count ) = split '\s*,\s*';

             my $epoch = DateTime::Format::Flexible->parse_datetime($date)->epoch;
             my $time = 1000 * $epoch;
             $contestant{$who}{$time} = $count;
         }

         my @json;  # data structure that is going to be JSONified

         while ( my ( $peep, $data ) = each %contestant ) {
             push @json, { 
                 label     => $peep,
                 hoverable => \1,    # so that it becomes JavaScript's 'true'
                 data => [ map  { [ $_, $data->{$_} ] } 
                         sort { $a <=> $b } 
                         keys %$data ],
             };
         }

         my $beginning = DateTime::Format::Flexible->parse_datetime( "2010-11-01")->epoch;
         my $end       = DateTime::Format::Flexible->parse_datetime( "2010-12-01")->epoch;

         push @json, {
             label => 'de par',
             data => [
                 [$beginning * 1000, 0],
                 [   DateTime->now->epoch * 1_000,
                     50_000 
                       * (DateTime->now->epoch - $beginning)
                       / ($end - $beginning)
                 ]
               ],

         };

         to_json( \@json );
     };

For more serious AJAX interaction, there's also L<Dancer2::Plugin::Ajax> 
that adds an I<ajax> route handler to the mix.

=head2 Using the prefix feature to split your application

For better maintainability, you may want to separate some of your application
components into different packages. Let's say we have a simple web app with an
admin section and want to maintain this in a different package:

    package myapp;
    use Dancer2;
    use myapp::admin;

    prefix undef;

    get '/' => sub {...};

    1;

    package myapp::admin;
    use Dancer2 appname => 'myapp';

    prefix '/admin';

    get '/' => sub {...};

    1;

The following routes will be generated for us:

    - get /
    - get /admin/
    - head /
    - head /admin/

By default, a separate application is created for every package that uses
Dancer2. The C<appname> tag is used to collect routes and hooks into a
single Dancer2 application. In the above example, C<appname =E<gt> 'myapp'>
adds the routes from C<myapp::admin> to the routes of the app C<myapp>.

When using multiple applications please ensure that your path definitions do
not overlap. For example, if using a default route as described above, once
a request is matched to the default route then no further routes (or
applications) would be reached.

=head2 Delivering custom error pages

=head3 At the Core

In Dancer2, creating new errors is done by creating a new L<Dancer2::Core::Error>

     my $oopsie = Dancer2::Core::Error->new(
         status  => 418,
         message => "This is the Holidays. Tea not acceptable. We want eggnog.",
         context => $context,
     )

If not given, the status code defaults to a 500, there is no need for a message if 
we feel taciturn, and while the C<$context> (which is a I<Dancer::Core::Context> 
object holding all the pieces of information related to the current request) is 
needed if we want to take advantage of the templates, we can also do without.

However, to be seen by the end user, we have to populate the L<Dancer2::Core::Response>
object with the error's data. This is done via:

     $oopsie->throw($response);

Or, if we want to use the response object already present in the C<$context> 
(which is usually the case):

     $oopsie->throw;

This populates the status code of the response, sets its content, and throws a 
I<halt()> in the dispatch process.

=head3 What it will look like

The error object has quite a few ways to generate its content.

First, it can be explicitly given

     my $oopsie = Dancer::Core::Error->new(
         content => '<html><body><h1>OMG</h1></body></html>',
     );

If the C<$context> was given, the error will check if there is a 
template by the name of the status code (so, say you're using Template 
Toolkit, I<418.tt>) and will use it to generate the content, passing it 
the error's C<$message>, C<$status> code and C<$title> (which, if not 
specified, will be the standard http error definition for the status code).

If there is no template, the error will then look for a static page (to 
continue with our example, I<418.html>) in the I<public/> directory.

And finally, if all of that failed, the error object will fall back on 
an internal template.

=head3 Errors in Routes

The simplest way to use errors in routes is:

     get '/xmas/gift/:gift' => sub {
         die "sorry, we're all out of ponies\n" 
             if param('gift') eq 'pony';
     };

The die will be intercepted by Dancer, converted into an error (status 
code 500, message set to the dying words) and passed to the response.

In the cases where more control is required, C<send_error()> is the way to go:

     get '/glass/eggnog' => sub {
         send_error "Sorry, no eggnog here", 418;
     };

And if total control is needed:

     get '/xmas/wishlist' => sub {
         Dancer::Core::Error->new(
             response => response(),
             status   => 406,
             message  => "nothing but coal for you, I'm afraid",
             template => 'naughty/index',
         )->throw unless user_was_nice();

         ...;
     };

=head2 Authentication

Writing a form for authentication is simple: we check the user credentials 
on a request and decide whether to continue or redirect them to a form. 
The form allows them to submit their username and password and we save that 
and create a session for them so when they now try the original request, 
we recognize them and allow them in.

=head3 Basic Application

The application is fairly simple. We have a route that needs authentication, 
we have a route for showing the login page, and we have a route for posting 
login information and creating a session.

     package MyApp;
     use Dancer2;

     get '/' => sub {
         session('user')
             or redirect('/login');

         template index => {};
     };

     get '/login' => sub {
         template login => {};
     };

     post '/login' => sub {
         my $username  = param('username');
         my $password  = param('password');
         my $redir_url = param('redirect_url') || '/login';

         $username eq 'john' && $password eq 'correcthorsebatterystaple'
             or redirect $redir_url;

         session user => $username;
         redirect $redir_url;
     };

=head3 Tiny Authentication Helper

L<Dancer2::Plugin::Auth::Tiny> allows you to abstract away not only the 
part that checks whether the session exists, but to also generate a 
redirect with the right path and return URL.

We simply have to define what routes needs a login using Auth::Tiny's 
C<needs> keyword.

     get '/' => needs login => sub {
         template index => {};
     };

It creates a proper return URL using C<uri_for> and the address from which 
the user arrived.

We can thus decorate all of our private routes to require authentication in 
this manner. If a user does not have a session, it will automatically forward 
it to I</login>, in which we would render a form for the user to send a login request.

Auth::Tiny even provides a new parameter, C<return_url>, which can be used to send 
the user back to their original requested path.

=head3 Password Hashing

L<Dancer2::Plugin::Passphrase> provides a simple passwords-as-objects interface with 
sane defaults for hashed passwords which you can use in your web application. It uses 
B<bcrypt> as the default but supports anything the L<Digest> interface does.

Assuming we have the original user-creation form submitting a username and password:

     package MyApp;
     use Dancer2;
     use Dancer2::Plugin::Passphrase;
     post '/register' => sub {
         my $username = param('username');
         my $password = passphrase( param('password') )->generate;

         # $password is now a hashed password object
         save_user_in_db( $username, $password->rfc2307 );

         template registered => { success => 1 };
     };

We can now add the B<POST> method for verifying that username and password:

     post '/login' => sub {
         my $username   = param('username');
         my $password   = param('password');
         my $saved_pass = fetch_password_from_db($username);

         if ( passphrase($password)->matches($saved_pass) ) {
             session user => $username;
             redirect param('return_url') || '/';
         }

         # let's render instead of redirect...
         template login => { error => 'Invalid username or password' };
     };
     
=head2 Accessing configuration information from a separate script

You may want to access your webapp's configuration from outside your
webapp. You could, of course, use the YAML module of your choice and load
your webapps's C<config.yml>, but chances are that this is not convenient.

Use Dancer2 instead. You can simply use
the values from C<config.yml> and some additional default values:

    # bin/show_app_config.pl
    use Dancer2;
    print "template:".config->{template}."\n"; # simple
    print "log:".config->{log}."\n"; # undef

Note that C<< config->{log} >> should result in an uninitialized warning
on a default scaffold since the environment isn't loaded and
log is defined in the environment and not in C<config.yml>. Hence C<undef>.

Dancer2 will load your C<config.yml> configuration file along with the
correct environment file located in your C<environments> directory.

The environment is determined by two environment variables in the following
order:

=over 4

=item * DANCER_ENVIRONMENT

=item * PLACK_ENV

=back

If neither of those is set, it will default to loading the development
environment (typically C<$webapp/environment/development.yml>).

If you wish to load a different environment, you need to override these
variables.

You can call your script with the environment changed:

    $ PLACK_ENV=production perl bin/show_app_config.pl

Or you can override them directly in the script (less recommended):

    BEGIN { $ENV{'DANCER_ENVIRONMENT'} = 'production' }
    use Dancer2;

    ...

=head2 Template Toolkit's WRAPPER directive in Dancer2

Dancer2 already provides a WRAPPER-like ability, which we call a "layout".
The reason we don't use Template Toolkit's WRAPPER (which also makes us incompatible with
it) is because not all template systems support it. Actually, most don't.

However, you might want to use it, and be able to define META variables and
regular L<Template::Toolkit> variables.

These few steps will get you there:

=over 4

=item * Disable the layout in Dancer2

You can do this by simply commenting (or removing) the C<layout>
configuration in the config file.

=item * Use the Template Toolkit template engine

Change the configuration of the template to Template Toolkit:

    # in config.yml
    template: "template_toolkit"

=item * Tell the Template Toolkit engine which wrapper to use

    # in config.yml
    # ...
    engines:
        template:
            template_toolkit:
                WRAPPER: layouts/main.tt

=back

Done! Everything will work fine out of the box, including variables and META
variables.

=head2 Creating a service

You can turn your app into a proper service running in the background using one of
the following examples.

=head3 Using Ubic

L<Ubic> is an extensible perlish service manager. You can use it to start
and stop any services, automatically start them on reboots or daemon
failures, and implement custom status checks.

A basic PSGI service description (usually in C</etc/ubic/service/application>):

    use parent qw(Ubic::Service::Plack);

    # if your application is not installed in @INC path:
    sub start {
        my $self = shift;
        $ENV{PERL5LIB} = '/path/to/your/application/lib';
        $self->SUPER::start(@_);
    }

    __PACKAGE__->new(
        server => 'Starman',
        app => '/path/to/your/application/app.psgi',
        port => 5000,
        user => 'www-data',
    );

Run C<ubic start application> to start the service.

=head3 Using daemontools

daemontools is a collection of tools for managing UNIX services. You can use
it to easily start/restart/stop services.

A basic script to start an application: (in C</service/application/run>)

    #!/bin/sh

    # if your application is not installed in @INC path:
    export PERL5LIB='/path/to/your/application/lib'

    exec 2>&1 \
    /usr/local/bin/plackup -s Starman -a /path/to/your/application/app.psgi -p 5000

=head2 Running stand-alone behind a proxy / load balancer

Another option would be to run your app stand-alone as described above, but
then use a proxy or load balancer to accept incoming requests (on the
standard port 80, say) and feed them to your Dancer2 app.

This could be achieved using various software; examples would include:

=head3 Using Apache's C<mod_proxy>

You could set up a C<VirtualHost> for your web app, and proxy all requests
through to it:

    <VirtualHost mywebapp.example.com:80>
    ProxyPass / http://localhost:3000/
    ProxyPassReverse / http://localhost:3000/
    </VirtualHost>

Or, if you want your webapp to share an existing VirtualHost, you could have
it under a specified dir:

    ProxyPass /mywebapp/ http://localhost:3000/
    ProxyPassReverse /mywebapp/ http://localhost:3000/

It is important for you to note that the Apache2 modules C<mod_proxy> and
C<mod_proxy_http> must be enabled:

    $ a2enmod proxy
    $ a2enmod proxy_http

It is also important to set permissions for proxying for security purposes,
below is an example.

    <Proxy *>
      Order allow,deny
      Allow from all
    </Proxy>

=head3 Using perlbal

C<perlbal> is a single-threaded event-based server written in Perl
supporting HTTP load balancing, web serving, and a mix of the two, available
from L<http://www.danga.com/perlbal/>.

It processes hundreds of millions of requests a day just for LiveJournal,
Vox and TypePad and dozens of other "Web 2.0" applications.

It can also provide a management interface to let you see various
information on requests handled etc.

It could easily be used to handle requests for your Dancer2 apps, too.

It can be easily installed from CPAN:

    perl -MCPAN -e 'install Perlbal'

Once installed, you'll need to write a configuration file. See the examples
provided with perlbal, but you'll probably want something like:

    CREATE POOL my_dancers
    POOL my_dancers ADD 10.0.0.10:3030
    POOL my_dancers ADD 10.0.0.11:3030
    POOL my_dancers ADD 10.0.0.12:3030
    POOL my_dancers ADD 10.0.0.13:3030

    CREATE SERVICE my_webapp
    SET listen          = 0.0.0.0:80
    SET role            = reverse_proxy
    SET pool            = my_dancers
    SET persist_client  = on
    SET persist_backend = on
    SET verify_backend  = on
    ENABLE my_webapp

=head3 Using balance

C<balance> is a simple load-balancer from Inlab Software, available from
L<http://www.inlab.de/balance.html>.

It could be used simply to hand requests to a standalone Dancer2 app. You
could even run several instances of your Dancer2 app, on the same machine or
on several machines, and use a machine running C<balance> to distribute the
requests between them, for some serious heavy traffic handling!

To listen on port 80, and send requests to a Dancer2 app on port 3000:

    balance http localhost:3000

To listen on a specified IP only on port 80, and distribute requests between
multiple Dancer2 apps on multiple other machines:

    balance -b 10.0.0.1 80 10.0.0.2:3000 10.0.0.3:3000 10.0.0.4:3000

=head3 Using lighttpd

You can use lighttp's C<mod_proxy>:

    $HTTP["url"] =~ "/application" {
        proxy.server = (
            "/" => (
                "application" => ( "host" => "127.0.0.1", "port" => 3000 )
            )
        )
    }

This configuration will proxy all requests to the C</application> path to the
path C</> on localhost:3000.

=head3 Using Nginx

with Nginx:

    upstream backendurl {
        server unix:THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock;
    }

    server {
      listen       80;
      server_name YOUR_HOST_HERE;

      access_log /var/log/YOUR_ACCESS_LOG_HERE.log;
      error_log  /var/log/YOUR_ERROR_LOG_HERE.log info;

      root YOUR_ROOT_PROJECT/public;
      location / {
        try_files $uri @proxy;
        access_log off;
        expires max;
      }

      location @proxy {
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass       http://backendurl;
      }

    }

You will need plackup to start a worker listening on a socket :

    cd YOUR_PROJECT_PATH
    sudo -u www plackup -E production -s Starman --workers=2 \
        -l THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock -a bin/app.psgi

A good way to start this is to use C<daemontools> and place this line with
all environments variables in the "run" file.

=head2 Turning off warnings

The C<warnings> pragma is already used when one loads Dancer2. However, if
you I<really> do not want the C<warnings> pragma (for example, due to an
undesired warning about use of undef values), add a C<no warnings> pragma to
the appropriate block in your module or psgi file.

=head2 Writing a REST application

With Dancer2, it's easy to write REST applications. Dancer2 provides helpers
to serialize and deserialize for the following data formats:

=over 4

=item JSON

=item YAML

=item XML

=item Data::Dumper

=back

To activate this feature, you only have to set the C<serializer> setting to
the format you require, for instance in your config file:

   serializer: JSON

Or directly in your code:

   set serializer => 'JSON';

From now, all hashrefs or arrayrefs returned by a route will be serialized
to the format you chose, and all data received from B<POST> or B<PUT>
requests will be automatically deserialized.

    get '/hello/:name' => sub {
        # this structure will be returned to the client as
        # {"name":"$name"}
        return {name => params->{name}};
    };

It's possible to let the client choose which serializer to use. For
this, use the C<mutable> serializer, and an appropriate serializer will be
chosen from the C<Content-Type> header.

It's also possible to return a custom error using the
L<send_error|Dancer2/send_error> keyword. When you don't use a serializer,
the C<send_error> function will take a string as first parameter (the
message), and an optional HTTP code. When using a serializer, the message
can be a string, an arrayref or a hashref:

    get '/hello/:name' => sub {
        if (...) {
           send_error("you can't do that");
           # or
           send_error({reason => 'access denied', message => "no"});
        }
    };

The content of the error will be serialized using the appropriate
serializer.

=head2 Using the serializer

Serializers essentially do two things:

=over 4

=item * Deserialize incoming requests

When a user makes a request with serialized input, the serializer 
automatically deserializes it into actual input parameters.

=item * Serialize outgoing responses

When you return a data structure from a route, it will automatically 
serialize it for you before returning it to the user.

=back

=head3 Configuring

In order to configure a serializer, you just need to pick which format 
you want for encoding/decoding (from L<Dancer2::Serializer>) and set it 
up using the C<serializer> configuration keyword.

It is recommended to explicitly add it in the actual code instead of the 
configuration file so it doesn't apply automatically to every app that 
reads the configuration file (unless that's what you want):

     package MyApp;
     use Dancer2;
     set serializer => 'JSON'; # Dancer2::Serializer::JSON

     ...

=head3 Using

Now that we have a serializer set up, we can just return data structures:

     get '/' => sub {
         return { resources => \%resources };
     };

When we return this data structure, it will automatically be serialized 
into JSON. No other code is necessary.

We also now receive requests in JSON:

     post '/:entity/:id' => sub {
         my $entity = param('entity');
         my $id     = param('id');

         # input which was sent serialized
         my $user = param('user');

         ...
     };

We can now make a serialized request:

     $ curl -X POST http://ourdomain/person/16 -d '{"user":"sawyer_x"}'

=head3 App-specific feature

Serializers are engines. They affect a Dancer Application, which means 
that once you've set a serializer, B<all> routes within that package 
will be serialized and deserialized. This is how the feature works.

As suggested above, if you would like to have both, you need to create 
another application which will not be serialized.

A common usage for this is an API providing serialized endpoints (and 
receiving serialized requests) and providing rendered pages.

     # MyApp.pm
     package MyApp;
     use Dancer2;

     # another useful feature:
     set auto_page => 1;

     get '/' => sub { template 'index' => {...} };

     # MyApp/API.pm
     package MyApp::API;
     use Dancer2;
     set serializer => 'JSON'; # or any other serializer

     get '/' => sub { +{ resources => \%resources, ... } };

     # user-specific routes, for example
     prefix => '/users' => sub {
         get '/view'     => sub {...};
         get '/view/:id' => sub {...};
         put '/add'      => sub {...}; # automatically deserialized params
     };

     ...

Then those will be mounted together for a single app:

     # handler: app.pl:
     use MyApp;
     use MyApp::API;
     use Plack::Builder;

     builder {
         mount '/'    => MyApp->to_app;
         mount '/api' => MyApp::API->to_app;
     };

=head3 An example: Writing API interfaces

This example demonstrates an app that makes a request to a weather 
API and then displays it dynamically in a web page.

Other than L<Dancer2> for defining routes, we will use L<HTTP::Tiny> 
to make the weather API request, L<JSON> to decode it from JSON format, 
and finally L<File::Spec> to provide a fully-qualified path to our 
template engine.

     use JSON;
     use Dancer2;
     use HTTP::Tiny;
     use File::Spec; 

=head4 Configuration

We use the L<Template::Toolkit> template system for this app.
Dancer searches for our templates in our views directory, which defaults 
to I<views> directory in our current directory. Since we want to put our 
template in our current directory, we will configure that. However, 
I<Template::Toolkit> does not want us to provide a relative path without 
configuring it to allow it. This is a security issue. So, we're using 
L<File::Spec> to create a full path to where we are.

We also unset the default layout, so Dancer won't try to wrap our template 
with another one. This is a feature in Dancer to allow you to wrap your 
templates with a layout when your templating system doesn't support it. Since 
we're not using a layout here, we don't need it.

     set template => 'template_toolkit';       # set template engine
     set layout   => undef;                    # disable layout
     set views    => File::Spec->rel2abs('.'); # full path to views

Now, we define our URL:

     my $url = 'http://api.openweathermap.org/data/2.5/weather?id=5110629&units=imperial';

=head4 Route

We will define a main route which, upon a request, will fetch the information 
from the weather API, decode it, and then display it to the user.

Route definition:

     get '/' => sub {
         ...
     };

Editing the stub of route dispatching code, we start by making the request 
and decoding it:

     # fetch data
     my $res = HTTP::Tiny->new->get($url);

     # decode request
     my $data = decode_json $res->{'content'};

The data is not just a flat hash. It's a deep structure. In this example, we 
will filter it for only the simple keys in the retrieved data:

     my $metrics = { map +(
         ref $data->{$_} ? () : ( $_ => $data->{$_} )
     ), keys %{$data} };

All that is left now is to render it:

     template index => { metrics => $metrics };
