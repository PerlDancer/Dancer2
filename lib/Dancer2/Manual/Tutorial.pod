package Dancer2::Tutorial;
# ABSTRACT: A step-by-step guide to get you dancing

=encoding utf8

=pod

=head1 Dancer2 Tutorial

The point is to gradually build up from simple examples and demonstrations
of techniques and end up with a working blog application.

=head1 Introduction - the Danceyland Blog

=head2 What You'll Learn

=head2 Prerequisites

Linux, BSD, or Windows with WSL and a Linux distribution installed.

Windows with Stawberry Perl may work, but is not guaranteed.

You'll also need SQLite 3, installed via your operating system's package
manager.

=head1 Setting Up Your Environment

=head2 Installing Dancer2

    cpan Dancer2

or

    cpanm Dancer2

=head2 Creating Your First App

    dancer2 -a DLBlog

Output:

    + DLBlog
    + DLBlog/.dancer
    + DLBlog/config.yml
    + DLBlog/cpanfile
    + DLBlog/Makefile.PL
    + DLBlog/MANIFEST.SKIP
    + DLBlog/t
    + DLBlog/t/002_index_route.t
    + DLBlog/t/001_base.t
    + DLBlog/environments
    + DLBlog/environments/production.yml
    + DLBlog/environments/development.yml
    + DLBlog/bin
    + DLBlog/bin/app.psgi
    + DLBlog/views
    + DLBlog/views/index.tt
    + DLBlog/public
    + DLBlog/public/dispatch.cgi
    + DLBlog/public/404.html
    + DLBlog/public/favicon.ico
    + DLBlog/public/500.html
    + DLBlog/public/dispatch.fcgi
    + DLBlog/lib
    + DLBlog/lib/DLBlog.pm
    + DLBlog/views/layouts
    + DLBlog/views/layouts/main.tt
    + DLBlog/public/images
    + DLBlog/public/images/perldancer.jpg
    + DLBlog/public/images/perldancer-bg.jpg
    + DLBlog/public/javascripts
    + DLBlog/public/javascripts/jquery.js
    + DLBlog/public/css
    + DLBlog/public/css/style.css
    + DLBlog/public/css/error.css

    Your new application is ready! To run it:

        cd DLBlog
        plackup bin/app.psgi

    To access your application, point your browser to http://localhost:5000

    If you need community assistance, the following resources are available:
    - Dancer website: https://perldancer.org
    - Twitter: https://twitter.com/PerlDancer/
    - GitHub: https://github.com/PerlDancer/Dancer2/
    - Mailing list: https://lists.perldancer.org/mailman/listinfo/dancer-users
    - IRC: irc.perl.org#dancer

    Happy Dancing!

Make sure to change to your new project directory to begin work:

    cd DLBlog

=head2 Understanding Directory Structure

Your application directory now contains several subdirectories:

=over

=item bin

Contains the PSGI file that starts your application. Can be used for
other utilities and scripts for your application.

=item environments

Configuration information. One file per environment (such as C<development>
and C<production>)

=item lib

Your core application code. This is where you'll put your models,
controllers, and other code.

=item public

Contains static files such as images, CSS, and JavaScript. Also contains
instance scripts for CGI and FastCGI.

=item t

Tests for your application.

=item views

Contains templates and layouts.

=back

=head2 Using Plackup for Development

    plackup -r bin/app.psgi

This autorestarts your application when changes are made to your code.
This is ideal during development, but should not be used in a production
setting.

=head1 Configuring Our Application

By default, new Dancer2 applications use L<Dancer2::Template::Simple>.
While this works well for the simplest of apps, it's not well suited to
applications like the Danceyland Blog. Instead, we'll configure this
application to use L<Template::Toolkit>, a mainstay of Perl templating.

To enable Template Toolkit, you'll need to edit your F<config.yml>:

    # template engine
    # simple: default and very basic template engine
    # template_toolkit: TT

    #template: "simple"

    template: "template_toolkit"
    engines:
      template:
        template_toolkit:
          # Note: start_tag and end_tag are regexes
          start_tag: '<%'
          end_tag:   '%>'

YAML files, such as your application config, support the same comment
characters as Perl. L<Dancer2::Template::Simple> is disabled by commenting
that line in your config file, and the default TT config is used by
uncommenting the C<template> and C<engines> configuration.

This tells Dancer2 to:

=over

=item Load the Template Toolkit template engine

=item Specify Template Toolkit as the template engine to use

=item Passes configuration to the TT engine (C<start_tag, end_tag>)

=back

We'll visit this file regularly throughout the tutorial.

F<config.yml> is the right place to set configuration common to all
environments (dev, production, etc.), such as the template engine to use.
Later, we'll see how to use different configuration parameters in
different environments.

=head1 CRUD Routes

CRUD is an acronym for Create, Read, Update, and Delete. These are the
basic operations for any database-driven application, such as the
Danceyland Blog.

=head2 What Routes are Needed?

Blogs contain one or more entries, which we need to be able to Create,
Read, Update, and Delete. We'll need the following routes:

=over

=item *

Create a blog entry. This corresponds to the HTTP C<POST> method. It also
requires a form to input the data, which is displayed using the HTTP C<GET>
method.

=item *

Read (i.e., display) a blog entry. This corresponds to the HTTP C<GET>
method.

=item *

Update a blog entry. If we were building an API or single-page application,
this would correspond to the HTTP C<PUT> or C<PATCH> methods. In a
traditional CRUD-based web application, this will use the C<POST> method.

There is a UI component to this as well, which will use the HTTP C<GET>
method.

=item *

Delete a blog entry. If we were building an API or single-page application,
this would correspond to the HTTP C<DELETE> method. However, for simplicity,
we'll use the HTTP C<GET> method to prompt the user for confirmation, and a
C<POST> route to actually perform the deletion.

=back

We'll also need a route to see the list of all blog entries. This will use
the HTTP C<GET> method.

TODO: can/should we combine the routes below with the CRUD explanation
above?

=head3 Add an Entry (Create)

This requires two routes: one to display the create form, and another to
process the input and create the entry.

To display the entry form:

    get '/create' => sub {
        return "Show the entry form";
    };

To process the input and create the blog entry:

    post '/create' => sub {
        return "Creates the new blog entry";
    };

=head3 Display an Entry (Read)

This route is similar to the one needed to display the creation form:

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        return "Showing entry ID $id";
    };

The route declaration contains a parameter this time: the id of the
blog entry we wish to view. The C<route_parameters> keyword is used to
fetch the ID passed to our application.

=head3 Update an Entry (Update)

As with adding an entry, this requires two routes: one to dosplay the
entry form, and another to process the changes:

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the update form for entry id $id";
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Updates the specified blog entry";
    };

Again, the entry ID is provided to our Dancer2 application as a route
parameter.

=head3 Delete an Entry (Delete)

This also needs two routes: one to confirm the user wants to delete the
blog entry, and another to actually delete it:

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the delete confirmation for entry id $id";
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Deletes the specified blog entry";
    };

=head3 Displaying the Entry List

Finally, we need a route to display the list of all blog entries:

    get '/' => sub {
        return "Show the list of blog entries";
    };

=head2 Putting it all Together

So far, F<lib/DLBlog.pm> should look like this:

    package DLBlog;
    use Dancer2;

    get '/' => sub {
        return "Show the list of blog entries";
    };

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        return "Showing entry ID $id";
    };

    get '/create' => sub {
        return "Show the entry form";
    };

    post '/create' => sub {
        return "Creates the new blog entry";
    };

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the update form for entry id $id";
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Updates the specified blog entry";
    };

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the delete confirmation for entry id $id";
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Deletes the specified blog entry";
    };

    true;

=head3 Run your application!

Let's see how it works. From the shell:

    plackup -r bin/app.psgi

Then open your browser and test your GET routes (we have nothing to post
yet!):

    L<http://localhost:5000/>
    L<http://localhost:5000/entry/1>
    L<http://localhost:5000/create>
    L<http://localhost:5000/update/1>
    L<http://localhost:5000/delete/1>

=head1 Setting Up Views

=head2 Layout

Let's replace F<views/layouts/main.tt> with simple HTML5 boilerplate:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="<% settings.charset %>">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title><% title %></title>
        <link rel="stylesheet" href="<% request.uri_base %>/css/style.css">
      </head>
      <body>
        <% content %>
        <div id="footer">
        Powered by <a href="https://perldancer.org/">Dancer2</a> <% dancer_version %>
        </div>
      </body>
    </html>

This gives us a barebones framework to build our blog into. It sets proper
encoding of characters, an application title, adds a stylesheet, and adds
a footer containing the version of Dancer2 powering the blog.

=head2 Templates

The special C<< <% content %> >> variable above is where templates used
by our routes will display. Instead of returning a string from the routes
defined above, let's create some templates that will contain the UI
necessary to interact with the blog, along with some business logic to
display them at the right time.

=head3 The Index Route (C</>)

Replace the existing F<views/index.tt> with the following:

    <div id="entries">
    <% IF entries.size %>
        <dl>
        <% FOREACH entry IN entries %>
            <dt><a href="/entry/<% entry.id %>"><% entry.title | html_entity %></a>
                (created at <% entry.created_at | html_entity %>)</dt>
            <dd><% entry.summary | html_entity %></dd>
        <% END %>
        </dl>
    <% ELSE %>
        <p>No entries found.</p>
    <% END %>
    </div>

This list will be populated when we read entries from the database later
in this tutorial.

What's with all these C<html_entity> things? The C<|> is Template Toolkit
syntax for a filter, and C<html_entity> represents the filter we are using.
This particular filter properly excapes characters like ampersands when
displaying them as HTML.

To use this template in our app, we'll use the C<template> keyword to plug
this into our route:

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', { entries => \@entries };
    };

=head3 The View Entry Route C</entry/:id>

We'll create a new template, F<views/entry.tt>, that contains everything
we think we'll need to show a blog entry:

    <% IF entry %>
    <div id="sidebar">
        <h1>Posted at</h1>
        <p><% entry.created_at | html_entity %></p>
        <h1>Summary</h1>
        <p><% entry.summary | html_entity %></p>
    </div>
    <div id="content">
        <h2><% entry.title | html_entity %></h2>
        <p><% entry.body | html_entity %></p>
    <% ELSE %>
        <p>Invalid entry.</p>
    <% END %>
    </div>

C<entry> is a hashref that has the contents of our blog post.  If a valid
entry ID isn't provided, we give the user a message explaining so.
Otherwise, we'll provide a two column layout with metadata in the sidebar,
and blog content on the main part of the page.

This is going to be ugly as written; we'll add some styling at the end to
make things look nicer.

Let's modify our route for viewing entries to use this template:

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        my $entry; # Populated from the database later
        template 'entry', { entry => $entry };
    };

=head3 The Create Entry Routes C</create>

This is just a simple form to create a new blog entry. Create
F<views/create.tt> with the following:

    <div id="create">
        <form method="post" action="<% request.uri_for('/create') %>">
            <label for="title">Title</label>
            <input type="text" name="title" id="title"><br>
            <label for="summary">Summary</label>
            <input type="text" name="summary" id="summary"><br>
            <label for="content">Content</label>
            <textarea name="body" id="body" cols="50" rows="10"></textarea><br>
            <input type="submit">
        </form>
    </div>

Using C<uri_for> when specifying the POST URL allows Dancer2 to create a
proper URL no matter where your app is running from.

This can be added to the create route:

    get '/create' => sub {
        template 'create';
    };

There is no template when POSTing to C</create>. There are two possible
outcomes when creating a blog entry:

=over

=item Creation was successful, so we redirect somewhere sensible

=item Creation failed, so we redisplay the filled in form and show an error

=back

We'll show how to do both of these in the implementation section later.
For now:

    post '/create' => sub {
        my $new_id = 1;
        redirect uri_for "/entry/$new_id"; # redirect does not need a return
    };

=head3 The Update Entry Routes (C</update/:id>)

Showing the UI for updating a blog entry is similar to what we did in
create above, except that we will need to display the existing values
of an entry in the form (we don't want to make the user re-enter
everything when updating, do we?). Since we have no values to show right
now, we will implement this latter part in the implementation section
below.

For now, let's just return the existing create form:

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        template 'create';
    };

We don't need a special template for displaying the results of an update,
we just need to show the resulting entry. Don't we already have a route
that does that though? Why should we do that work again here? We shouldn't!

Dancer2 will let you change the flow of your application using the
C<forward> or C<redirect> keywords. But which should we choose?

=over

=item C<forward> is an internal redirect

This lets you perform the functionality contained in another route, but
it's done internally, which means that the URL shown to the user in their
browser's address bar looks like the one they requested. In the case of
our update, the browser bar will show C<http://localhost:5000/update/1>,
but what they would be seeing is the output from C<http://localhost:5000/entry/1>.
This is not desirable, as it is confusing for a user to look at.

=item C<redirect> is an external redirect

External redirects sends the user to a different URL by sending a redirect
response from Dancer2. Even though the user is executing a POST to
C<http://localhost:5000/update/1>, upon completion, they're browser bar
will show C<http://localhost:5000/entry/1>. This is a better option, as
when an update completes successfully, the URL will match what the user sees
in their browser.

To do this, let's use the redirect keyword:

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        redirect uri_for "/entry/$id"; # redirect does not need a return
    };

We will show how to update an existing entry later in the tutorial.

=back

=head3 The Delete Routes

It's wouldn't be kind to the user to simply delete an entry without giving
them the option to change their mind, and that's what the GET route for
deletion is intended to do.

Let's give the user a simple confirmation form. Create F<views/delete.tt>:

    <div id="delete">
        <form method="post" action="<% request.uri_for('/delete/' _ id) %>">
            <p>Delete entry <% id %>. Are you sure?</p>
            <p>
                <input type="radio" id="yes" name="delete_it" value="yes">
                <label for="yes">Yes</label>
            </p>
            <p>
                <input type="radio" id="no" name="delete_it" value="no">
                <label for="no">No</label>
            </p>
            <input type="submit">
        </form>
    </div>

Our GET route for delete will need to change:

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        template 'delete', { id => $id };
    };

Similar to create and update, there's no need to create another template
to show the results of a delete. We'll just send the user back to the
list of blog entries:

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

Notice the addition of the C<body_parameters>? This is to get the value
of the radio button the user selected. This is important to decide if
the user actually wants to delete or not.

=head2 Reviewing our Application Code

F<lib/DLBlog.pm> should now look like this:

    package DLBlog;
    use Dancer2;

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', { entries => \@entries };
    };

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        my $entry; # Populated from the database later
        template 'entry', { entry => $entry };
    };

    get '/create' => sub {
        template 'create';
    };

    post '/create' => sub {
        my $new_id = 1;
        redirect uri_for "/entry/$new_id"; # redirect does not need a return
    };

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        template 'create';
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        redirect uri_for "/entry/$id";
    };

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        template 'delete', { id => $id };
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

    true;

=head2 Adding Utility to our Views

This is all well and good, but it's not the most functional for our users.
A basic menu of available options would help users to understand what
actions can be performed in the Danceyland Blog.

=head3 Adding a Menu to our Layout

Let's edit our layout so users can see the same list of options across all
pages. By adding the menu once to the layout, we don't have to reproduce
this in the list, create, update, and delete templates.

Our menu will look like this:

    <div id="menu">
        <a href="<% request.uri_for('/') %>">List All Entries</a>&nbsp;|&nbsp;
        <a href="<% request.uri_for('/create') %>">Create New Entry</a>
    </div>

Now, let's add it to the top of our layout. The end result looks like:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="<% settings.charset %>">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title><% title %></title>
        <link rel="stylesheet" href="<% request.uri_base %>/css/style.css">
      </head>
      <body>
        <div id="menu">
            <a href="<% request.uri_for('/') %>">List All Entries</a>&nbsp;|&nbsp;
            <a href="<% request.uri_for('/create') %>">Create New Entry</a>
        </div>
        <% content %>
        <div id="footer">
        Powered by <a href="https://perldancer.org/">Dancer2</a> <% dancer_version %>
        </div>
      </body>
    </html>

Refresh your browser to see the menu appear at the top of your page.

=head3 Adding Messages to our Layout

It's easy to tell if create was successful, but what about update and
delete? Wouldn't it be nice to receive some confirmation that an update
or delete worked as intended? To do this, let's add the ability to
display a message via our layout.

Let's create a simple message display to add to our layout:

    <% IF message %>
    <div id="message">
        <b><% message | html_entity %></b>
    </div>
    <% END %>

The C<IF> around the message C<div> makes it so this only is added to the
resulting page if there is a message to show the user. After adding this
to F<views/layouts/main.tt>, the layout should look like:

If you want to see the message show up in your application, just pass a
parameter named C<message> to your template. Let's add a friendly message
temporarily when looking at the list of blog entries (we'll remove this
later):

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', {
            entries => \@entries,
            message => 'Welcome to the Danceyland Blog!',
        };
    };

We'll add some styling later to make this stand out more.

This works well if we need to generate a message and display it on a
template in our route, but what if we need to show that message on
another request? We'll need to save that message somewhere so it can
get picked up by the next request.

=head1 Sessions

Sessions allow us to introduce persistence in our web applications. This
manifests itself in many different ways, be it remembering the currently
logged in user, or remembering form entries between pages on a multi-page
form. Sessions give us a mechanism for "remembering" things.

Sessions require a storage mechanism to power them. Some common storage
engines for sessions include memory caches, files, and databases (SQL and
NoSQL both).

While sessions are generally managed server side, but can also be found
client side in secure cookies and browser local storage.

For purposes of this tutorial, we're going to use Dancer2's YAML session
engine, L<Dancer2::Session::YAML>. By keeping our sessions in YAML, it's
easy to look at the contents of a session while we are developing and
debugging the blog.

=head2 Setting Up a Session Engine

Session engines work much like template engines; there require a little
bit of setup in your application's config file, and then they are available
for use throughout the application.

To set up the YAML session engine, add the following to your F<config.yml>:

    session: "YAML"

    engines:
      session:
        YAML:
          cookie_name: dlblog.session

You can only have one C<engines> section, so this should be combined with
your existing template configuration. The section should now look like:

    template: "template_toolkit"
    session: "YAML"
    engines:
      template:
        template_toolkit:
          # Note: start_tag and end_tag are regexes
          start_tag: '<%'
          end_tag:   '%>'
      session:
        YAML:
          cookie_name: dlblog.session

=head2 Storing and Retrieving Session Data

We can use our session to store messages to be displayed across requests.

Store session data with the C<session> keyword:

    session message => "Deleted entry $id";

Retrieving session data can also be done with the C<session> keyword:

    my $message = session 'message';

Let's add a message to our delete route:

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            session message => "Deleted entry $id";
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

And display it at the top of our list of entries:

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', {
            entries => \@entries,
            message => session 'message',
        };
    };

Now confirm you want to delete an entry here:

    L<http://localhost:5000/delete/1>

You can verify the message was written to the session by looking at the
session file created on disk. If you look in your project directory, you'll
notice a new F<sessions/> directory. There should now be exactly one file
there: your current session. Run the following:

    $ cat sessions/<some session id>.yml

You'll have a file that looks like:

    ---
    message: Deleted entry 1

YAML files are great for sessions while developing, but they are not a
good choice for production. We'll examine some other options when we
discuss deploying to production later in this tutorial.

Now, refresh the current page. Did you spot the problem? That message now
shows on I<every> request! We need a way to clear messages once they are
displayed. This is where hooks can be useful. We'll learn more about them
later in the tutorial.

For a more robust solution for persisting data one-time across requests,
check out L<Dancer2::Plugin::Deferred>.

=head2 Our Application So Far

Your application module should now look like:

    package DLBlog;
    use Dancer2;

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', {
            entries => \@entries,
            message => session 'message',
        };
    };

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        my $entry; # Populated from the database later
        template 'entry', { entry => $entry };
    };

    get '/create' => sub {
        template 'create';
    };

    post '/create' => sub {
        my $new_id = 1;
        session entry_id => $new_id;
        redirect uri_for "/entry/$new_id"; # redirect does not need a return
    };

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        template 'create';
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        redirect uri_for "/entry/$id";
    };

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        template 'delete', { id => $id };
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            session message => "Deleted entry $id";
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

    true;

=head1 The Danceyland Database

We need some way to persist the blog entries, and relational databases
excel at this. We'll use SQLite for this tutorial, but you can use any
database supported by L<Dancer2::Plugin::Database> and L<DBI>.

L<SQLite|https://sqlite.org> is a lightweight, single file database that
makes it easy to add relational database functionality to a low-concurrency
web application.

=head2 Setting Up the Database

At minimum, we need to create a table to contain our blog entries. Create
a new directory for your database and SQL files:

    $ mkdir db

Then create a new file, F<db/entries.sql>, with the following:

    CREATE TABLE entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        summary TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

Later, we'll add an additional table for users.

Let's create our blog database with the above table. From our project
directory:

    $ sqlite3 db/dlblog.db < db/entries.sql

=head2 Using Dancer2::Plugin::Database

L<Dancer2::Plugin::Database> is a plugin that provides a simple interface
to a database via L<DBI>. It allows you to connect to a database and execute
SQL queries. The plugin also provides some additional syntax to make it
easier to perform database queries from inside Dancer2 applications.

You'll also need to install two other dependencies, L<DBI> (a universal
database interface) and L<DBD::SQLite> (the SQLite database driver).
Install them using C<cpan> or C<cpanm>:

    cpanm DBI DBD::SQLite Dancer2::Plugin::Database

And then add it to the top of F<lib/DLBlog.pm> after C<use Dancer2;>:

    use Dancer2::Plugin::Database;

=head1 Implementing the Danceyland Blog

Let's start by creating an entry and saving it to the database; all other
routes rely on us having at least one entry (in some form).

add some logging
Deliberately introduce an error that could be caught by logging
Log the details, but don't give too much information in the web ui!
For good measure, redirect to the new entry once it has been created.
Show some input sanitation (id, for example). Show how typed params can help here.

TODO: C<forward> accepts parameters for messaging

TODO:
Update to create. Same form, with values filled in
Make form another template to include
Macro for displaying a value if one present

=head2 Performing Queries

It is generally considered bad practice to issue C<SELECT *> in production
applications. For example, if your application is expecting columns in a
certain order, and the DBA makes a change that introduces new columns in
the middle of a table, suddenly your application has a bug that needs to be
fixed.

It is considered better practice to explicitly list the columns you need
to use when performing a query. This protects your application, and
potentially your users, from unexpected changes outside of your application.

=head2 Displaying Blog Data

=head2 Maintaining State

Congratulations! You've added all the basic functionality! Now, let's secure.

=head1 Authentication

=head2 Dancer2::Plugin::Auth::Tiny

=head2 Changing Session ID

=head2 Using Hooks

=head1 Adding File Uploads

=head2 Setting Up Routes for Uploads

=head2 Saving and Displaying Uploaded Files

=head1 Finishing Touches

=head2 Adding Middleware

=head2 Error Handling and Custom Error Pages

=head1 Testing Your Application

=head2 Using Test::WWW::Mechanize::PSGI

=head1 Deployment

=head2 Creating Production Configuration

=head2 Deploying with a PSGI Server

=head2 Configuring Reverse Proxy with NGINX

=head2 What You've Built

=head2 Where to Go Next

# mention liteblog

=cut
