package Dancer2::Tutorial;
# ABSTRACT: A step-by-step guide to get you dancing

=encoding utf8

=pod

=head1 Dancer2 Tutorial

In this tutorial, you're going to end up with a working blog application,
constructed from simple examples and demonstrations of techniques used
in Dancer2 applications.

If you'd like to see the finished product, you can clone the git repository
containing the code used in this tutorial:

    git clone https://github.com/PerlDancer/DLBlog.git

=head1 Introduction - the Danceyland Blog

Danceyland wants to share information about happenings at the park on
an ongoing basis, and feel the best medium for doing so is by publishing
a blog. Your task is to construct a blog engine to facilitate this using
Dancer2 and other Perl modules.

=head2 What You'll Learn

By the end of this tutorial, you'll know how to:

=over

=item * Scaffold a new Dancer2 app

=item * Design and construct routes for an application

=item * Work with sessions, templates, and databases

=item * Extend your Dancer2 applications with plugins

=item * Add authentication to Dancer2 applications

=item * Perform a basic app deployment

=back

=head2 Prerequisites

=over

=item * Linux, BSD, or Windows with WSL and a Linux distribution installed

(Strawberry Perl on Windows may work, but is not guaranteed)

=item * SQLite 3, installed via your operating system's package manager

=back

=head1 Setting Up Your Environment

=head2 Installing Dancer2

    cpan Dancer2

or

    cpanm Dancer2

=head2 Creating Your First App

    dancer2 -a DLBlog

Output:

    + DLBlog
    + DLBlog/.dancer
    + DLBlog/config.yml
    + DLBlog/cpanfile
    + DLBlog/Makefile.PL
    + DLBlog/MANIFEST.SKIP
    + DLBlog/t
    + DLBlog/t/002_index_route.t
    + DLBlog/t/001_base.t
    + DLBlog/environments
    + DLBlog/environments/production.yml
    + DLBlog/environments/development.yml
    + DLBlog/bin
    + DLBlog/bin/app.psgi
    + DLBlog/views
    + DLBlog/views/index.tt
    + DLBlog/public
    + DLBlog/public/dispatch.cgi
    + DLBlog/public/404.html
    + DLBlog/public/favicon.ico
    + DLBlog/public/500.html
    + DLBlog/public/dispatch.fcgi
    + DLBlog/lib
    + DLBlog/lib/DLBlog.pm
    + DLBlog/views/layouts
    + DLBlog/views/layouts/main.tt
    + DLBlog/public/images
    + DLBlog/public/images/perldancer.jpg
    + DLBlog/public/images/perldancer-bg.jpg
    + DLBlog/public/javascripts
    + DLBlog/public/javascripts/jquery.js
    + DLBlog/public/css
    + DLBlog/public/css/style.css
    + DLBlog/public/css/error.css

    Your new application is ready! To run it:

        cd DLBlog
        plackup bin/app.psgi

    To access your application, point your browser to http://localhost:5000

    If you need community assistance, the following resources are available:
    - Dancer website: https://perldancer.org
    - Twitter: https://twitter.com/PerlDancer/
    - GitHub: https://github.com/PerlDancer/Dancer2/
    - Mailing list: https://lists.perldancer.org/mailman/listinfo/dancer-users
    - IRC: irc.perl.org#dancer

    Happy Dancing!

Make sure to change to your new project directory to begin work:

    cd DLBlog

=head2 Understanding Directory Structure

Your application directory now contains several subdirectories:

=over

=item bin

Contains the PSGI file that starts your application. Can be used for
other utilities and scripts for your application.

=item environments

Configuration information. One file per environment (such as C<development>
and C<production>)

=item lib

Your core application code. This is where you'll put your models,
controllers, and other code.

=item public

Contains static files such as images, CSS, and JavaScript. Also contains
instance scripts for CGI and FastCGI.

=item t

Tests for your application.

=item views

Contains templates and layouts.

=back

=head2 Using Plackup for Development

    plackup -r bin/app.psgi

This autorestarts your application when changes are made to your code.
This is ideal during development, but should not be used in a production
setting.

=head1 Configuring Our Application

By default, new Dancer2 applications use L<Dancer2::Template::Simple>.
While this works well for the simplest of apps, it's not well suited to
applications like the Danceyland Blog. Instead, we'll configure this
application to use L<Template::Toolkit>, a mainstay of Perl templating.

To enable Template Toolkit, you'll need to edit your F<config.yml>:

    # template engine
    # simple: default and very basic template engine
    # template_toolkit: TT

    #template: "simple"

    template: "template_toolkit"
    engines:
      template:
        template_toolkit:
          # Note: start_tag and end_tag are regexes
          start_tag: '<%'
          end_tag:   '%>'

YAML files, such as your application config, support the same comment
characters as Perl. L<Dancer2::Template::Simple> is disabled by commenting
that line in your config file, and the default TT config is used by
uncommenting the C<template> and C<engines> configuration.

This tells Dancer2 to:

=over

=item Load the Template Toolkit template engine

=item Specify Template Toolkit as the template engine to use

=item Passes configuration to the TT engine (C<start_tag, end_tag>)

=back

We'll visit this file regularly throughout the tutorial.

F<config.yml> is the right place to set configuration common to all
environments (dev, production, etc.), such as the template engine to use.
Later, we'll see how to use different configuration parameters in
different environments.

=head1 CRUD Routes

CRUD is an acronym for Create, Read, Update, and Delete. These are the
basic operations for any database-driven application, such as the
Danceyland Blog.

=head2 What Routes are Needed?

Blogs contain one or more entries, which we need to be able to Create,
Read, Update, and Delete. We'll need the following routes:

=over

=item *

Create a blog entry. This corresponds to the HTTP C<POST> method. It also
requires a form to input the data, which is displayed using the HTTP C<GET>
method.

=item *

Read (i.e., display) a blog entry. This corresponds to the HTTP C<GET>
method.

=item *

Update a blog entry. If we were building an API or single-page application,
this would correspond to the HTTP C<PUT> or C<PATCH> methods. In a
traditional CRUD-based web application, this will use the C<POST> method.

There is a UI component to this as well, which will use the HTTP C<GET>
method.

=item *

Delete a blog entry. If we were building an API or single-page application,
this would correspond to the HTTP C<DELETE> method. However, for simplicity,
we'll use the HTTP C<GET> method to prompt the user for confirmation, and a
C<POST> route to actually perform the deletion.

=back

We'll also need a route to see the list of all blog entries. This will use
the HTTP C<GET> method.

TODO: can/should we combine the routes below with the CRUD explanation
above?

=head3 Add an Entry (Create)

This requires two routes: one to display the create form, and another to
process the input and create the entry.

To display the entry form:

    get '/create' => sub {
        return "Show the entry form";
    };

To process the input and create the blog entry:

    post '/create' => sub {
        return "Creates the new blog entry";
    };

=head3 Display an Entry (Read)

This route is similar to the one needed to display the creation form:

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        return "Showing entry ID $id";
    };

The route declaration contains a parameter this time: the id of the
blog entry we wish to view. The C<route_parameters> keyword is used to
fetch the ID passed to our application.

=head3 Update an Entry (Update)

As with adding an entry, this requires two routes: one to dosplay the
entry form, and another to process the changes:

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the update form for entry id $id";
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Updates the specified blog entry";
    };

Again, the entry ID is provided to our Dancer2 application as a route
parameter.

=head3 Delete an Entry (Delete)

This also needs two routes: one to confirm the user wants to delete the
blog entry, and another to actually delete it:

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the delete confirmation for entry id $id";
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Deletes the specified blog entry";
    };

=head3 Displaying the Entry List

Finally, we need a route to display the list of all blog entries:

    get '/' => sub {
        return "Show the list of blog entries";
    };

=head2 Putting it all Together

So far, F<lib/DLBlog.pm> should look like this:

    package DLBlog;
    use Dancer2;

    get '/' => sub {
        return "Show the list of blog entries";
    };

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        return "Showing entry ID $id";
    };

    get '/create' => sub {
        return "Show the entry form";
    };

    post '/create' => sub {
        return "Creates the new blog entry";
    };

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the update form for entry id $id";
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        return "Updates the specified blog entry";
    };

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Show the delete confirmation for entry id $id";
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        return "Deletes the specified blog entry";
    };

    true;

=head3 Run your application!

Let's see how it works. From the shell:

    plackup -r bin/app.psgi

Then open your browser and test your GET routes (we have nothing to post
yet!):

    L<http://localhost:5000/>
    L<http://localhost:5000/entry/1>
    L<http://localhost:5000/create>
    L<http://localhost:5000/update/1>
    L<http://localhost:5000/delete/1>

=head1 Setting Up Views

=head2 Layout

Let's replace F<views/layouts/main.tt> with simple HTML5 boilerplate:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="<% settings.charset %>">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title><% title %></title>
        <link rel="stylesheet" href="<% request.uri_base %>/css/style.css">
      </head>
      <body>
        <% content %>
        <div id="footer">
        Powered by <a href="https://perldancer.org/">Dancer2</a> <% dancer_version %>
        </div>
      </body>
    </html>

This gives us a barebones framework to build our blog into. It sets proper
encoding of characters, an application title, adds a stylesheet, and adds
a footer containing the version of Dancer2 powering the blog.

=head2 Templates

The special C<< <% content %> >> variable above is where templates used
by our routes will display. Instead of returning a string from the routes
defined above, let's create some templates that will contain the UI
necessary to interact with the blog, along with some business logic to
display them at the right time.

=head3 The Index Route (C</>)

Replace the existing F<views/index.tt> with the following:

    <div id="entries">
    <% IF entries.size %>
        <dl>
        <% FOREACH entry IN entries %>
            <dt><a href="/entry/<% entry.id %>"><% entry.title | html_entity %></a>
                (created at <% entry.created_at | html_entity %>)</dt>
            <dd><% entry.summary | html_entity %></dd>
        <% END %>
        </dl>
    <% ELSE %>
        <p>No entries found.</p>
    <% END %>
    </div>

This list will be populated when we read entries from the database later
in this tutorial.

What's with all these C<html_entity> things? The C<|> is Template Toolkit
syntax for a filter, and C<html_entity> represents the filter we are using.
This particular filter properly excapes characters like ampersands when
displaying them as HTML.

To use this template in our app, we'll use the C<template> keyword to plug
this into our route:

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', { entries => \@entries };
    };

=head3 The View Entry Route C</entry/:id>

We'll create a new template, F<views/entry.tt>, that contains everything
we think we'll need to show a blog entry:

    <% IF entry %>
    <div id="sidebar">
        <h1>Posted at</h1>
        <p><% entry.created_at | html_entity %></p>
        <h1>Summary</h1>
        <p><% entry.summary | html_entity %></p>
    </div>
    <div id="content">
        <h2><% entry.title | html_entity %></h2>
        <p><% entry.content | html_entity %></p>
    <% ELSE %>
        <p>Invalid entry.</p>
    <% END %>
    </div>

C<entry> is a hashref that has the contents of our blog post.  If a valid
entry ID isn't provided, we give the user a message explaining so.
Otherwise, we'll provide a two column layout with metadata in the sidebar,
and blog content on the main part of the page.

This is going to be ugly as written; we'll add some styling at the end to
make things look nicer.

Let's modify our route for viewing entries to use this template:

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        my $entry; # Populated from the database later
        template 'entry', { entry => $entry };
    };

=head3 The Create Entry Routes C</create>

This is just a simple form to create a new blog entry. Create
F<views/create.tt> with the following:

    <div id="create">
        <form method="post" action="<% request.uri_for('/create') %>">
            <label for="title">Title</label>
            <input type="text" name="title" id="title"><br>
            <label for="summary">Summary</label>
            <input type="text" name="summary" id="summary"><br>
            <label for="content">Content</label>
            <textarea name="content" id="content" cols="50" rows="10"></textarea><br>
            <input type="submit">
        </form>
    </div>

Using C<uri_for> when specifying the POST URL allows Dancer2 to create a
proper URL no matter where your app is running from.

This can be added to the create route:

    get '/create' => sub {
        template 'create';
    };

There is no template when POSTing to C</create>. There are two possible
outcomes when creating a blog entry:

=over

=item Creation was successful, so we redirect somewhere sensible

=item Creation failed, so we redisplay the filled in form and show an error

=back

We'll show how to do both of these in the implementation section later.
For now:

    post '/create' => sub {
        my $new_id = 1;
        redirect uri_for "/entry/$new_id"; # redirect does not need a return
    };

=head3 The Update Entry Routes (C</update/:id>)

Showing the UI for updating a blog entry is similar to what we did in
create above, except that we will need to display the existing values
of an entry in the form (we don't want to make the user re-enter
everything when updating, do we?). Since we have no values to show right
now, we will implement this latter part in the implementation section
below.

For now, let's just return the existing create form:

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        template 'create';
    };

We don't need a special template for displaying the results of an update,
we just need to show the resulting entry. Don't we already have a route
that does that though? Why should we do that work again here? We shouldn't!

Dancer2 will let you change the flow of your application using the
C<forward> or C<redirect> keywords. But which should we choose?

=over

=item C<forward> is an internal redirect

This lets you perform the functionality contained in another route, but
it's done internally, which means that the URL shown to the user in their
browser's address bar looks like the one they requested. In the case of
our update, the browser bar will show C<http://localhost:5000/update/1>,
but what they would be seeing is the output from C<http://localhost:5000/entry/1>.
This is not desirable, as it is confusing for a user to look at.

=item C<redirect> is an external redirect

External redirects sends the user to a different URL by sending a redirect
response from Dancer2. Even though the user is executing a POST to
C<http://localhost:5000/update/1>, upon completion, they're browser bar
will show C<http://localhost:5000/entry/1>. This is a better option, as
when an update completes successfully, the URL will match what the user sees
in their browser.

To do this, let's use the redirect keyword:

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        redirect uri_for "/entry/$id"; # redirect does not need a return
    };

We will show how to update an existing entry later in the tutorial.

=back

=head3 The Delete Routes

It's wouldn't be kind to the user to simply delete an entry without giving
them the option to change their mind, and that's what the GET route for
deletion is intended to do.

Let's give the user a simple confirmation form. Create F<views/delete.tt>:

    <div id="delete">
        <form method="post" action="<% request.uri_for('/delete/' _ id) %>">
            <p>Delete entry <% id %>. Are you sure?</p>
            <p>
                <input type="radio" id="yes" name="delete_it" value="yes">
                <label for="yes">Yes</label>
            </p>
            <p>
                <input type="radio" id="no" name="delete_it" value="no">
                <label for="no">No</label>
            </p>
            <input type="submit">
        </form>
    </div>

Our GET route for delete will need to change:

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        template 'delete', { id => $id };
    };

Similar to create and update, there's no need to create another template
to show the results of a delete. We'll just send the user back to the
list of blog entries:

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

Notice the addition of the C<body_parameters>? This is to get the value
of the radio button the user selected. This is important to decide if
the user actually wants to delete or not.

=head2 Reviewing our Application Code

F<lib/DLBlog.pm> should now look like this:

    package DLBlog;
    use Dancer2;

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', { entries => \@entries };
    };

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        my $entry; # Populated from the database later
        template 'entry', { entry => $entry };
    };

    get '/create' => sub {
        template 'create';
    };

    post '/create' => sub {
        my $new_id = 1;
        redirect uri_for "/entry/$new_id"; # redirect does not need a return
    };

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        template 'create';
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        redirect uri_for "/entry/$id";
    };

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        template 'delete', { id => $id };
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

    true;

=head2 Adding Utility to our Views

This is all well and good, but it's not the most functional for our users.
A basic menu of available options would help users to understand what
actions can be performed in the Danceyland Blog.

=head3 Adding a Menu to our Layout

Let's edit our layout so users can see the same list of options across all
pages. By adding the menu once to the layout, we don't have to reproduce
this in the list, create, update, and delete templates.

Our menu will look like this:

    <div id="menu">
        <a href="<% request.uri_for('/') %>">List All Entries</a>&nbsp;|&nbsp;
        <a href="<% request.uri_for('/create') %>">Create New Entry</a>
    </div>

Now, let's add it to the top of our layout. The end result looks like:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="<% settings.charset %>">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title><% title %></title>
        <link rel="stylesheet" href="<% request.uri_base %>/css/style.css">
      </head>
      <body>
        <div id="menu">
            <a href="<% request.uri_for('/') %>">List All Entries</a>&nbsp;|&nbsp;
            <a href="<% request.uri_for('/create') %>">Create New Entry</a>
        </div>
        <% content %>
        <div id="footer">
        Powered by <a href="https://perldancer.org/">Dancer2</a> <% dancer_version %>
        </div>
      </body>
    </html>

Refresh your browser to see the menu appear at the top of your page.

=head1 The Danceyland Database

We need some way to persist the blog entries, and relational databases
excel at this. We'll use SQLite for this tutorial, but you can use any
database supported by L<Dancer2::Plugin::Database> and L<DBI>.

L<SQLite|https://sqlite.org> is a lightweight, single file database that
makes it easy to add relational database functionality to a low-concurrency
web application.

=head2 Setting Up the Database

At minimum, we need to create a table to contain our blog entries. Create
a new directory for your database and SQL files:

    $ mkdir db

Then create a new file, F<db/entries.sql>, with the following:

    CREATE TABLE entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        summary TEXT NOT NULL,
        content TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

Later, we'll add an additional table for users.

Let's create our blog database with the above table. From our project
directory:

    $ sqlite3 db/dlblog.db < db/entries.sql

=head2 Using Dancer2::Plugin::DBIx::Class

L<Dancer2::Plugin::DBIx::Class> is a plugin that integrates the
L<DBIx::Class> Object Relational Mapper (ORM) and Dancer2. It maps tables,
rows, and columns into classes, objects, and methods in Perl. L<DBIx::Class>
(DBIC for short) makes it convenient to work with databases in your Perl
applications and reduces a lot of manual SQL creation.

DBIC is also a large and complex beast, and can take some time to become
proficient with it. This tutorial merely scrapes the surface of what you
can do with it; for more information, check out
L<DBIx::Class::Manual::DocMap>.

You'll also need to install two other dependencies, L<DBD::SQLite> (the
SQLite database driver), L<DBIx::Class::Schema::Loader> (for automatically
generating database classes from tables), and L<DateTime::Format::SQLite>
(to interact with dates in DBIC objects).

Install them using C<cpan> or C<cpanm>:

    cpanm DBD::SQLite Dancer2::Plugin::DBIx::Class \
        DBIx::Class::Schema::Loader DateTime::Format::SQLite

And then add it to the top of F<lib/DLBlog.pm> after C<use Dancer2;>:

    use Dancer2::Plugin::DBIx::Class;

We need to add configuration to tell our plugin where to find the SQLite
database. For this project, it's sufficient to put configuration for
the database in F<config.yml>. In a production application, you'd
have different database credentials in your development and staging
environments than you would in your production environment (we'd hope you
would anyhow!). And this is where environment config files are handy.

By default, Dancer2 runs your application in the development environment.
To that end, we'll add plugin configuration appropriately. Add the following
to your F<environments/development.yml> file:

    plugins:
      DBIx::Class:
        default:
          dsn: "dbi:SQLite:dbname=db/dlblog.db"
          schema_class: "DLBlog::Schema"
          dbi_params:
            RaiseError: 1
            AutoCommit: 1

Note that we only provided C<DBIx::Class> for the plugin name; Dancer2
automatically infers the C<Dancer2::Plugin::> prefix.

As SQLite databases are a local file, we don't need to provide login
credentials for the database. The two settings in the C<dbi_params>
section tell L<DBIx::Class> to raise an error automatically to our code
(should one occur), and to automatically manage transactions for us (so
we don't have to).

=head1 Generating Schema Classes

L<DBIx::Class> relies on class definitions to map database tables to
Perl constructs. Thankfully, L<DBIx::Class::Schema::Loader> can do much
of this work for us.

To generate the schema object, and a class that represents the C<entries>
table, run the following from your shell:

    dbicdump -o dump_directory=./lib \
        -o components='["InflateColumn::DateTime"]' \
        DLBlog::Schema dbi:SQLite:db/dlblog.db '{ quote_char => "\"" }'

This creates two new files in your application:

=over

=item * F<lib/DLBlog/Schema.pm>

This is a class that represents all database schema.

=item * F<lib/DLBlog/Schema/Result/Entry.pm>

This is a class representing a single row in the C<entries> table.

=back

=head1 Implementing the Danceyland Blog

Let's start by creating an entry and saving it to the database; all other
routes rely on us having at least one entry (in some form).

=head2 Performing Queries

L<Dancer2::Plugin::DBIx::Class> lets us easily perform SQL queries against
a database. It does this by providing methods to interact with data, such
as C<find>, C<search>, C<create>, and C<update>. These methods make for
simpler maintenance of code, as they do all the work of writing and executing
SQL in the background.

For example, let's use a convenience method to create a new blog entry.
Here's the form we created for entering a blog post:

    <div id="create">
        <form method="post" action="<% request.uri_for('/create') %>">
            <label for="title">Title</label>
            <input type="text" name="title" id="title"><br>
            <label for="summary">Summary</label>
            <input type="text" name="summary" id="summary"><br>
            <label for="content">Content</label>
            <textarea name="content" id="content" cols="50" rows="10"></textarea><br>
            <button type="submit">Save Entry</button>
        </form>
    </div>

We can take values submitted via this form and turn them into a row in
the database:

    post '/create' => sub {
        my $params = body_parameters();

        my $entry = do {
            try {
                resultset('Entry')->create( $params->as_hashref );
            }
            catch( $e ) {
                error "Database error: $e";
                var error_message => 'A database error occurred; your entry could not be created',
                forward '/create', {}, { method => 'GET' };
            }
        };
        redirect uri_for "/entry/" . $entry->id; # redirect does not need a return
    };

Form fields are sent to Dancer2 as body parameters, so we need to use the
C<body_parameters> keyword to get them:

    my $params = body_parameters();

This returns all body parameters as a single hashref, where each form
field name is a key, and the value is what the user input into the form.

In a production environment, you'd want to sanitize this data before
attempting a database operation. When you sanitize data, you are ensuring
that data contains only the values you would expect to receive. If it's
not what you'd expect, you can remove the extra cruft (sanitize), or ask
the user to correct their entry.

Database operations can fail, so we should make an attempt to trap any
errors. C<try/catch> lends itself well to this type of error checking.
Newer versions of Perl have a built-in C<try> keyword, but older versions
do not. To protect against this, let's install L<Feature::Compat::Try>,
which uses the built-in C<try> if your Perl has it, otherwise provides
a backported implementation. To install this module, run F<cpanm>:

    $ cpanm Feature::Compat::Try

Then make sure to include it at the top of your application:

    use Feature::Compat::Try;

The code inside the C<try> block will be executed, and if it fails, will
C<catch> the error, and execute the code in that block.

    try {
        resultset('Entry')->create( $params->as_hashref );
    }

This uses the C<quick_insert> method of our Database plugin, and passes
the values from the form through to create a row in the C<entries> table.

If a database error occurs, we need to handle it:

    catch( $e ) {
        error "Database error: $e";
        var error_message => 'A database error occurred; your entry could not be created',
        forward '/create', {}, { method => 'GET' };
    }

The first line creates an error log message containing the actual database
error; this will be valuable in helping to debug your application, or
troubleshoot a user issue. We then stash a message in a variable to be
displayed on the create page once it is redisplayed.
For the sake of brevity, we populate message with a really basic error
message. In a production application, you'd want to provide the user with
a more descriptive message to help them resolve their own problem, if
possible.

Why not pass the database error directly to the user? Because this gives
a potential attacker information about your database and application.

Finally, we send the user back to the entry form:

    forward uri_for '/create', {}, { method => 'GET' };

By default, C<forward> invokes a route with the same HTTP verb of the route
it is executing from. You can change the verb used by passing a third
hashref containing the C<method> key. The second (empty) hashref contains
an optional list of parameters to be passed to the forwarded route.

If the insert succeeds, C<create> returns an object that represents the
newly created database row, and assigns it to the variable C<$entry>.
We can perform additional database operations against this row by calling
methods on C<$entry>. As a convenience to the user, we should take them to
a page where they can view their new entry:

    debug 'Created entry ' . $entry->id . ' for "' . $entry->title . '"';
    redirect uri_for "/entry/" . $entry->id; # redirect does not need a return

The first line logs a message showing the post was successfully created,
then redirects the user to the entry display page on the last line.

=head3 Redisplaying the Create Form

In the case of an error, it's a good practice to redisplay the original
form with the previous values populated. We could add code in our POST
route to redisplay the form, or we could use the code we already wrote
to display the form instead. We'll go with the latter.

Dancer2's C<var> keyword lets you create variables to use elsewhere in
your application, including templates. We'll use these to keep track of
what the user has already entered, and to display a message to the user
if any required parameters are missing.

To save any entered parameters into vars, add this line right after the
call to C<body_parameters>:

    var $_ => $params->{ $_ } foreach qw< title summary content >;

Now, let's check if any of these were not provided when the user submitted
the create form:

    my @missing = grep { $params->{$_} eq '' } qw< title summary content >;
    if( @missing ) {
        var missing => join ",", @missing;
        warning "Missing parameters: " . var 'missing';
        forward '/create', {}, { method => 'GET' };
    }

If any of C<title>, C<summary>, or C<content> are missing, we build up
a message containing the list of missing parameters. We then set a variable,
C<missing>, with the message to display. Finally, we internally redirect
(via the C<forward> keyword) back to the GET route that displays our create
form.

Your new C<post '/create'> route should now look like this:

    post '/create' => sub {
        my $params = body_parameters();
        var $_ => $params->{ $_ } foreach qw< title summary content >;

        my @missing = grep { $params->{$_} eq '' } qw< title summary content >;
        if( @missing ) {
            var missing => join ",", @missing;
            warning "Missing parameters: " . var 'missing';
            forward '/create', {}, { method => 'GET' };
        }

        my $entry = do {
            try {
                resultset('Entry')->create( $params->as_hashref );
            }
            catch( $e ) {
                error "Database error: $e";
                var error_message => 'A database error occurred; your entry could not be created',
                forward '/create', {}, { method => 'GET' };
            }
        };

        debug 'Created entry ' . $entry->id . ' for "' . $entry->title . '"';
        redirect uri_for "/entry/" . $entry->id; # redirect does not need a return
    };

These changes to our C<post '/create'> route creates some succinct code
that's easy to follow, but may not be the best for a production application.
Better error handling could be added, retry logic for failed database
connections doesn't exist, data validation is lacking, etc. All of these
features can be added to the blog at a later time as additional exercises for
the developer.

=head3 Updating the create form to show previous values

We need to adjust the create form to show the values we stashed as
variables with the C<var> keyword:

    <div id="create">
        <form method="post" action="<% request.uri_for('/create') %>">
            <label for="title">Title</label>
            <input type="text" name="title" id="title" value="<% vars.title %>"><br>
            <label for="summary">Summary</label>
            <input type="text" name="summary" id="summary" value="<% vars.summary %>"><br>
            <label for="content">Content</label>
            <textarea name="content" id="content" cols="50" rows="10"><% vars.content %></textarea><br>
            <button type="submit">Save Entry</button>
        </form>
    </div>

Variables stashed in your Dancer2 application are available via the C<vars>
hashref, such as C<< <% vars.title %> >>. When C</create> displays this form,
any stashed variable values will be filled in to their appropriat form
element.

=head1 Displaying messages

In our application, we created a message to display a list of any missing
required fields. We also created an error message if our database operation
fails. Now, we need to create a place in the layout to display them.

Below our menu, but above our content, add the following:

    <% IF vars.missing %>
    <div id="missing">
        <b>Missing parameters: <% vars.missing | html_entity %></b>
    </div>
    <% END %>
    <% IF error_message %>
    <div id="error">
        <b>Error: <% vars.error_message | html_entity %></b>
    </div>
    <% END %>

This creates two message C<divs>: one that displays missing values, and
another that displays errors. Creating them separately allows us to more
easily style them appropriately later.

Notice the C<IF/END> blocks? This content is optional; i.e., if there are
no missing fields or error messages, this markup will not be added to the
rendered HTML page.

The layout should now look like:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="<% settings.charset %>">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title><% title %></title>
        <link rel="stylesheet" href="<% request.uri_base %>/css/style.css">
      </head>
      <body>
        <div id="menu">
            <a href="<% request.uri_for('/') %>">List All Entries</a>&nbsp;|&nbsp;
            <a href="<% request.uri_for('/create') %>">Create New Entry</a>
        </div>
        <% IF vars.missing %>
        <div id="missing">
            <b>Missing parameters: <% vars.missing | html_entity %></b>
        </div>
        <% END %>
        <% IF error_message %>
        <div id="error">
            <b>Error: <% vars.error_message | html_entity %></b>
        </div>
        <% END %>
        <% content %>
        <div id="footer">
        Powered by <a href="https://perldancer.org/">Dancer2</a> <% dancer_version %>
        </div>
      </body>
    </html>

=head2 Displaying Blog Data

Displaying a blog entry is fairly simple; the C<quick_select> method of
L<Dancer2::Plugin::Database> will return a database row as a hashref, which
can be passed as a parameter to a template:

    get '/entry/:id[Int]' => sub {
        my $id = route_parameters->get('id');
        my $entry = resultset( 'Entry' )->find( $id );
        template 'entry', { entry => $entry };
    };

You may notice the route declaration changed; Dancer2 will let you decorate
a route parameter with a L<Type::Tiny> datatype; if the provided parameter
doesn't match the type expected by Dancer2, an HTTP 404 status will be
returned. Any call to C<route_parameters> is then guaranteed to have a
value of the desired type.

We use the C<find()> method of L<DBIx::Class::ResultSet> to return a single
row and turn it into an object, which we will reference as C<$entry>. Should
C<find> not succeed, our template will display a message indicating so:

    <% IF entry %>
    <div id="sidebar">
        <h1>Posted at</h1>
        <p><% entry.created_at | html_entity %></p>
        <h1>Summary</h1>
        <p><% entry.summary | html_entity %></p>
    </div>
    <div id="content">
        <h2><% entry.title | html_entity %></h2>
        <p><% entry.content | html_entity %></p>
    <% ELSE %>
        <p>Invalid entry.</p>
    <% END %>
    </div>

By passing the resultset object directly to the template, you can call
methods directly on that object to display different columns of information,
such as C<title> and C<content>. If there is no valid entry, the C<ELSE>
section of the template will be displayed instead of the contents of the
blog post.

=head2 Updating a blog entry

To update a blog entry, we need a form that contains the values that have
already been entered for a given blog post. Didn't we already do that as
part of redisplaying the create form when it was missing values? Why yes
we did! What if we could reuse that form for editing an existing entry?
With a little bit of work, we absolutely can.

Rename F<create.tt> to be F<create_update.tt>, then replace the contents
with the following:

    <div id="create_update">
        <form method="post" action="<% post_to %>">
            <label for="title">title</label>
            <input type="text" name="title" id="title" value="<% vars.title %>"><br>
            <label for="summary">summary</label>
            <input type="text" name="summary" id="summary" value="<% vars.summary %>"><br>
            <label for="content">content</label>
            <textarea name="content" id="content" cols="50" rows="10"><% vars.content %></textarea><br>
            <button type="submit">Save Entry</button>
        </form>
    </div>

The following minor changes have been made:

=over

=item * The div id was changed to reflect the form's new purpose

=item * The form action was changed to the template variable C<post_to>

=back

The form action will be different based upon whether we are creating a new
blog entry, or updating an existing one.

We need to create a route to display the form such that it is suitable for
updating a blog entry:

    get '/update/:id[Int]' => sub {
        my $id = route_parameters->get('id');
        my $entry = resultset( 'Entry' )->find( $id );
        var $_ => $entry->$_ foreach qw< title summary content >;
        template 'create_update', { post_to => uri_for "/update/$id" };
    };

As with our route to display a blog entry, we include the type of parameter
(C<Int>) that we expect to receive. Dancer2 will issue a C<404> not found
error if this parameter is something other than an integer. We also attempt
to fetch the row from the C<entries> table identified with the id passed
to the application.

Once an entry has been retrieved, we populate the same list of variables
that we did to redisplay the form when required values were missing earlier.
Finally, we create the correct C<post_to> URL for updating a blog entry, and
pass it to the template.

As with create, we need a POST route to process the blog update:

    post '/update/:id[Int]' => sub {
        my $id = route_parameters->get('id');
        my $entry = resultset( 'Entry' )->find( $id );
        if( !$entry ) {
            status 'not_found';
            return "Attempt to update non-existent entry $id";
        }

        my $params = body_parameters();
        var $_ => $params->{ $_ } foreach qw< title summary content >;
        my @missing = grep { $params->{$_} eq '' } qw< title summary content >;
        if( @missing ) {
            var missing => join ",", @missing;
            warning "Missing parameters: " . var 'missing';
            forward "/update/$id", {}, { method => 'GET' };
        }

        try {
            $entry->update( $params->as_hashref );
        }
        catch( $e ) {
            error "Database error: $e";
            var error_message => 'A database error occurred; your entry could not be updated',
            forward "/update/$id", {}, { method => 'GET' };
        }
        redirect uri_for "/entry/" . $entry->id; # redirect does not need a return
    };

An additional check exists here that was unnecessary for create: a check to
ensure the blog post to update actually exists. If it doesn't, the proper
response is to issue a C<404> not found response to the user:

    if( !$entry ) {
        status 'not_found';
        return "Attempt to update non-existent entry $id";
    }

The C<status> keyword sets the proper response code in the response header,
and the message in the C<return> sends additional information back to the
user.

Once the proper blog entry has been loaded, the exact same logic needed
to create an entry applies to updating one.

=head3 Updating the create form's C<post_to>

Simply call C<uri_for> in our route, then pass the resulting value to
F<create_update.tt>:

    get '/create' => sub {
        # Vars are passed to templates automatically
        template 'create_update', { post_to => uri_for '/create' };
    };

=head2 Deleting a Blog Entry

=head2 Implementation Recap

Congratulations! You've added all the basic functionality! Now, let's secure
critical functions of this blog by putting a login in front of them.

# TODO: MOVE AND REWORK ALL THIS

=head1 Sessions

Sessions allow us to introduce persistence in our web applications. This
manifests itself in many different ways, be it remembering the currently
logged in user, or remembering form entries between pages on a multi-page
form. Sessions give us a mechanism for "remembering" things.

Sessions require a storage mechanism to power them. Some common storage
engines for sessions include memory caches, files, and databases (SQL and
NoSQL both).

While sessions are generally managed server side, but can also be found
client side in secure cookies and browser local storage.

For purposes of this tutorial, we're going to use Dancer2's YAML session
engine, L<Dancer2::Session::YAML>. By keeping our sessions in YAML, it's
easy to look at the contents of a session while we are developing and
debugging the blog.

=head2 Setting Up a Session Engine

Session engines work much like template engines; there require a little
bit of setup in your application's config file, and then they are available
for use throughout the application.

To set up the YAML session engine, add the following to your F<config.yml>:

    session: "YAML"

    engines:
      session:
        YAML:
          cookie_name: dlblog.session

You can only have one C<engines> section, so this should be combined with
your existing template configuration. The section should now look like:

    template: "template_toolkit"
    session: "YAML"
    engines:
      template:
        template_toolkit:
          # Note: start_tag and end_tag are regexes
          start_tag: '<%'
          end_tag:   '%>'
      session:
        YAML:
          cookie_name: dlblog.session

=head2 Storing and Retrieving Session Data

We can use our session to store messages to be displayed across requests.

Store session data with the C<session> keyword:

    session message => "Deleted entry $id";

Retrieving session data can also be done with the C<session> keyword:

    my $message = session 'message';

Let's add a message to our delete route:

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            session message => "Deleted entry $id";
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

And display it at the top of our list of entries:

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', {
            entries => \@entries,
            message => session 'message',
        };
    };

Now confirm you want to delete an entry here:

    L<http://localhost:5000/delete/1>

You can verify the message was written to the session by looking at the
session file created on disk. If you look in your project directory, you'll
notice a new F<sessions/> directory. There should now be exactly one file
there: your current session. Run the following:

    $ cat sessions/<some session id>.yml

You'll have a file that looks like:

    ---
    message: Deleted entry 1

YAML files are great for sessions while developing, but they are not a
good choice for production. We'll examine some other options when we
discuss deploying to production later in this tutorial.

Now, refresh the current page. Did you spot the problem? That message now
shows on I<every> request! We need a way to clear messages once they are
displayed. This is where hooks can be useful. We'll learn more about them
later in the tutorial.

For a more robust solution for persisting data one-time across requests,
check out L<Dancer2::Plugin::Deferred>.

=head2 Our Application So Far

Your application module should now look like:

    package DLBlog;
    use Dancer2;

    get '/' => sub {
        my @entries; # We'll populate this later
        template 'index', {
            entries => \@entries,
            message => session 'message',
        };
    };

    get '/entry/:id' => sub {
        my $id = route_parameters->get('id');
        my $entry; # Populated from the database later
        template 'entry', { entry => $entry };
    };

    get '/create' => sub {
        template 'create';
    };

    post '/create' => sub {
        my $new_id = 1;
        session entry_id => $new_id;
        redirect uri_for "/entry/$new_id"; # redirect does not need a return
    };

    get '/update/:id' => sub {
        my $id = route_parameters->get('id');
        template 'create';
    };

    post '/update/:id' => sub {
        my $id = route_parameters->get('id');
        redirect uri_for "/entry/$id";
    };

    get '/delete/:id' => sub {
        my $id = route_parameters->get('id');
        template 'delete', { id => $id };
    };

    post '/delete/:id' => sub {
        my $id = route_parameters->get('id');

        # Always default to not destroying data
        my $delete_it = body_parameters->get('delete_it') // 0;

        if( $delete_it ) {
            # Do the deletion here
            session message => "Deleted entry $id";
            redirect uri_for "/";
        } else {
            # Display our entry again
            redirect uri_for "/entry/$id";
        }
    };

    true;

=head1 Authentication

=head2 Dancer2::Plugin::Auth::Tiny

=head2 Dancer2::Plugin::CryptPassphrase

=head2 Changing Session ID

=head1 Finishing Touches

=head2 Adding some style

=head2 Using Hooks

=head2 Custom Error Pages

=head1 Testing Your Application

=head2 Using Test::WWW::Mechanize::PSGI

=head1 Deployment

=head2 Creating Production Configuration

=head2 Deploying with a PSGI Server

=head2 Configuring Reverse Proxy with NGINX

=head1 What You've Built

Congratulations! You have built a primitive but very functional blog
engine that protects maintenance functions behind a user login, using
L<Dancer2> and other plugins and modules in its ecosystem. You've learned
a number of important building blocks that will be crucial for building
other applications.

=head1 Where to Go Next

This application can be used as a springboard and reference for future
L<Dancer2> projects. There are still a number of improvements and additional
features that can be added to this blog. A few ideas include:

=over

=item Paginate the list of blog entries

After a while, the list of blog entries can get long. Using L<Data::Page>
or other Perl modules, break the list of entries into reasonable page
sizes to more easily and quickly navigate.

=item Add a search function to the blog

Add a search bar to the UI, then use the C<search()> method in
L<DBIx::Class> to find blog entries based on what the used input.

=item Improve application security by sanitizing input parameters

Using a regex or a validation framework (such as
L<Dancer2::Plugin::DataTransposeValidator>), scrub all input before using
it in a database operation.

=item Use database slugs in URLs instead of IDs

A database slug is a human-readable identifier (such as a URL encoding of
the entry title) that can be used to identify an entry rather than the
numerical ID. They are easier to remember than IDs, are better for SEO of
your content, and makes your application more secure by hiding some database
implementation details from an attacker (such as a row ID).

=item Move business logic to business layer; call business object from Dancer2

In larger applications, business logic (like creating a blog post) may
be put in an object (such as L<DBIx::Class::Result> or L<DBIx::Class::ResultSet>
objects, or other L<Moo> or L<Moose> objects), and that object gets
instantiated and called from Dancer2. This helps to decouple tasks in an
application, and allows for better testing of business logic.

=back

For another example of a blog engine in Dancer2, check out
L<Dancer2::Plugin::LiteBlog|LiteBlog> from our project founder, Sukria.

Happy Dancing!

=cut
